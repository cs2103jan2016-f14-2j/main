# A0135775W
###### \src\org\jimple\planner\constants\Constants.java
``` java
	/* -----------------|
	 * Parser Component |
	 * -----------------|
	 */
	// Extended commands for all the main commands.
	public static final String STRING_NAME = "NAME";
	public static final String STRING_DESC = "DESC";
	public static final String STRING_AT = "AT";
	public static final String STRING_FROM = "FROM";
	public static final String STRING_TO = "TO";
	public static final String STRING_ON = "ON";
	public static final String STRING_BY = "BY";
	public static final String STRING_LABEL = "LABEL";
	public static final String STRING_TIME = "TIME";
	public static final String STRING_COLOUR = "COLOUR";
	
	// Supported colours for labels.
	public static final String STRING_RED = "red";
	public static final String STRING_ORANGE = "orange";
	public static final String STRING_YELLOW = "yellow";
	public static final String STRING_GREEN = "green";
	public static final String STRING_BLUE = "blue";
	public static final String STRING_PURPLE = "purple";
	
	/* Stores the index for the user input directly after the main command.
	 *  - "ADD": Index of the task name.
	 *  - "EDIT": Index of the task ID.
	 *  - "DELETE": Index of the task ID.
	 *  - "SEARCH": Index of the query string.
	 *  - "CHANGEDIR": Index of the directory path.
	 *  - "EDITLABEL": Index of the label name.
	 */
	public static final int INDEX_BASE = 0;
	
	// Stores the indexes for task fields. Used by "ADD" and "EDIT".
	public static final int INDEX_NAME = 1;
	public static final int INDEX_DESCRIPTION = 2;
	public static final int INDEX_FROM = 3;
	public static final int INDEX_TO = 4;
	public static final int INDEX_LABEL = 5;
	
	// Stores the indexes for task fields. Used by "EDITLABEL".
	public static final int INDEX_EDITLABEL_NAME = 1;
	public static final int INDEX_EDITLABEL_COLOUR = 2;

	// Stores the task type strings for "ADD".
	public static final String TASK_TYPE_TODO = "todo";
	public static final String TASK_TYPE_DEADLINE = "deadline";
	public static final String TASK_TYPE_EVENT = "event";
	
	/**
	 * Logic component
	 */
```
###### \src\org\jimple\planner\exceptions\DuplicateDateTimeFieldException.java
``` java
@SuppressWarnings("serial")
public class DuplicateDateTimeFieldException extends Exception {

	public DuplicateDateTimeFieldException() {}
	
	public DuplicateDateTimeFieldException(String message) {
		super(message);
	}

}
```
###### \src\org\jimple\planner\exceptions\InvalidCommandException.java
``` java
@SuppressWarnings("serial")
public class InvalidCommandException extends Exception {

	public InvalidCommandException() {}
	
	public InvalidCommandException(String message) {
		super(message);
	}
	
}
```
###### \src\org\jimple\planner\exceptions\InvalidDateTimeFieldException.java
``` java
@SuppressWarnings("serial")
public class InvalidDateTimeFieldException extends Exception{

	public InvalidDateTimeFieldException() {}
	
	public InvalidDateTimeFieldException(String message) {
		super(message);
	}
	
}
```
###### \src\org\jimple\planner\exceptions\MissingDateTimeFieldException.java
``` java
@SuppressWarnings("serial")
public class MissingDateTimeFieldException extends Exception{

	public MissingDateTimeFieldException() {}
	
	public MissingDateTimeFieldException(String message) {
		super(message);
	}
}
```
###### \src\org\jimple\planner\parser\InputStruct.java
``` java

package org.jimple.planner.parser;

import org.jimple.planner.constants.Constants;

/* ------------|
 * INPUTSTRUCT |
 * ------------|
 * This class is the output of the Parser. It contains the command string and all possible variables for all
 * commands in the Jimple Planner. Stores the variables detected in the user
 * input.
 */

public class InputStruct {
	
	/* ---------------|
	 * SIZE VARIABLES |
	 * ---------------|
	 * Variables containing the intended size of the variable array for each command, used only in InputStruct.
	 */
	private final int ARRAY_SIZE_ADD = 6;
	private final int ARRAY_SIZE_EDIT = 6;
	private final int ARRAY_SIZE_DELETE = 1;
	private final int ARRAY_SIZE_SEARCH = 1;
	private final int ARRAY_SIZE_DONE = 1;
	private final int ARRAY_SIZE_RETURN = 1;
	private final int ARRAY_SIZE_EDITLABEL = 3;
	private final int ARRAY_SIZE_DELETELABEL = 1;
	private final int ARRAY_SIZE_CHECKCONFLICT = 1;
	private final int ARRAY_SIZE_CHANGEDIR = 1;

	private String commandString;

	// The string array being used, according to commandString.
	private String[] variableArray;

	public void setCommand(String inputCommand) {
		commandString = inputCommand;
	}

	public String getCommand() {
		return commandString;
	}

	public void setVariableArraySize(int inputSize) {
		variableArray = new String[inputSize];
	}

	public String[] getVariableArray(){
		if (variableArray != null) {
			return variableArray;
		} else {
			throw new NullPointerException("No variable array found.");
		}
	}

	/* ------------|
	 * CONSTRUCTOR |
	 * ------------|
	 * */
	public InputStruct(String inputCommandString) {
		commandString = inputCommandString;
		// Initializes the size of the variable array according to the commandString.
		switch (commandString) {
		case Constants.STRING_ADD :
			setVariableArraySize(ARRAY_SIZE_ADD);
			break;
		case Constants.STRING_EDIT :
			setVariableArraySize(ARRAY_SIZE_EDIT);
			break;
		case Constants.STRING_DELETE :
			setVariableArraySize(ARRAY_SIZE_DELETE);
			break;
		case Constants.STRING_SEARCH :
			setVariableArraySize(ARRAY_SIZE_SEARCH);
			break;
		case Constants.STRING_DONE :
			setVariableArraySize(ARRAY_SIZE_DONE);
			break;
		case Constants.STRING_RETURN :
			setVariableArraySize(ARRAY_SIZE_RETURN);
			break;
		case Constants.STRING_EDITLABEL :
			setVariableArraySize(ARRAY_SIZE_EDITLABEL);
			break;
		case Constants.STRING_DELETELABEL :
			setVariableArraySize(ARRAY_SIZE_DELETELABEL);
			break;
		case Constants.STRING_CHECKCONFLICT :
			setVariableArraySize(ARRAY_SIZE_CHECKCONFLICT);
			break;
		case Constants.STRING_CHANGEDIR :
			setVariableArraySize(ARRAY_SIZE_CHANGEDIR);
			break;
		default:
			break;
		}
	}
	
	/* Set the task type based on which date/time fields ("from" and "to") are available.
	 * EVENT: "from" & "to" set.
	 * DEADLINE: Only "from" set.
	 * TODO: None set.
	 */
	public void checkAndSetTaskType() {
		if (isTodo()) {
			setAtIndex(Constants.INDEX_BASE, Constants.TASK_TYPE_TODO);
		} else if (isDeadline()) {
			setAtIndex(Constants.INDEX_BASE, Constants.TASK_TYPE_DEADLINE);
		} else if (isEvent()) {
			setAtIndex(Constants.INDEX_BASE, Constants.TASK_TYPE_EVENT);
		}
	}
	
	private boolean isTodo() {
		return variableArray[Constants.INDEX_FROM] == null && variableArray[Constants.INDEX_TO] == null;
	}
	
	private boolean isDeadline() {
		return variableArray[Constants.INDEX_FROM] != null && variableArray[Constants.INDEX_TO] == null;
	}
	
	private boolean isEvent() {
		return variableArray[Constants.INDEX_FROM] != null && variableArray[Constants.INDEX_TO] != null;
	}

	/* --------------|
	 * ADD VARIABLES |
	 * --------------|
	 * Index 0: Task Type
	 *  - "todo": To-do
	 *  - "deadline": Deadline
	 *  - "event": Event
	 * Index 1: Task Name
	 * Index 2: Task Description
	 * Index 3: Task Time (From)
	 * Index 4: Task Time (To)
	 * Index 5: Task Label
	 */

	/* --------------|
	 * EDIT VARIABLES|
	 * --------------|
	 * Index 0: Task ID
	 * Index 1: Task Name
	 * Index 2: Task Description
	 * Index 3: Task Time (From)
	 * Index 4: Task Time (To)
	 * Index 5: Label Name
	 */

	/* ----------------|
	 * DELETE VARIABLE |
	 * ----------------|
	 * Index 0: Task ID
	 */

	/* ----------------|
	 * SEARCH VARIABLE |
	 * ----------------|
	 * Index 0: String to Search
	 */
	
	/* --------------|
	 * DONE VARIABLE |
	 * --------------|
	 * Index 0: Task ID
	 */
	
	/* ----------------|
	 * RETURN VARIABLE |
	 * ----------------|
	 * Index 0: Task ID
	 */
	
	/* --------------------|
	 * EDITLABEL VARIABLES |
	 * --------------------|
	 * Index 0: Label Name
	 * Index 1: New Label Name
	 * Index 2: New Label Colour
	 */
	
	/* ---------------------|
	 * DELETELABEL VARIABLE |
	 * ---------------------|
	 * Index 0: Label Name
	 */
	
	/* -----------------------|
	 * CHECKCONFLICT VARIABLE |
	 * -----------------------|
	 * Index 0: Task ID
	 */
	
	/* -------------------|
	 * CHANGEDIR VARIABLE |
	 * -------------------|
	 * Index 0: Directory String
	 */

	/* -----------------------------|
	 * HELP/CHECKDIR/UNDO VARIABLES |
	 * -----------------------------|
	 * N/A
	 */

	public void setAtIndex(int inputIndex, String inputString) {
		variableArray[inputIndex] = inputString;
	}

	public String getAtIndex(int inputIndex) {
		return variableArray[inputIndex];
	}
	
}

```
###### \src\org\jimple\planner\parser\Parser.java
``` java

package org.jimple.planner.parser;

import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.jimple.planner.constants.Constants;

import org.jimple.planner.exceptions.DuplicateDateTimeFieldException;
import org.jimple.planner.exceptions.InvalidCommandException;
import org.jimple.planner.exceptions.MissingDateTimeFieldException;

public class Parser {
			
	/* ----------------------------|
	 * EXTENDED COMMANDS CONSTANTS |
	 * ----------------------------| 
	 * String[]: Stores the possible extended command strings for each command.
	 */
	private final String[] EXTENDED_COMMANDS_ADD = {Constants.STRING_DESC, Constants.STRING_AT, Constants.STRING_FROM, Constants.STRING_ON, Constants.STRING_BY, Constants.STRING_LABEL};
	private final String[] EXTENDED_COMMANDS_EDIT = {Constants.STRING_NAME, Constants.STRING_DESC, Constants.STRING_TIME, Constants.STRING_LABEL};
	private final String[] EXTENDED_COMMANDS_EDITLABEL = {Constants.STRING_NAME, Constants.STRING_COLOUR};
	private final String[] EXTENDED_COMMANDS_NIL = {};
	
	/* --------------|
	 * VALID COLOURS |
	 * --------------|
	 * Supported colours for the labels, red to purple.
	 */ 
	private final String[] VALID_COLOURS = {Constants.STRING_RED, Constants.STRING_ORANGE, Constants.STRING_YELLOW, Constants.STRING_GREEN, Constants.STRING_BLUE, Constants.STRING_PURPLE};
	
	/* ------------------------|
	 * MISCELLANEOUS CONSTANTS |
	 * ------------------------|
	 * Constants which are only used in Parser.
	 */
	
	// Index of main command.
	private final int INDEX_MAIN_COMMAND = 0;
	// Index of user input following the main command
	private final int INDEX_MAIN_COMMAND_USER_INPUT = 1;
	private final int LENGTH_OF_COMMAND_WITH_USER_INPUT = 2;
	private final int LENGTH_OF_COMMAND_ONLY_MAIN_COMMAND = 1;
	private final int OFFSET_CALENDAR_MONTH = 1;
	private final int OFFSET_CALENDAR_YEAR = 1900;
	private final String EMPTY_STRING = "";
	private final String SPACE_STRING = " ";
	
	private final int INCREMENT_BY_1 = 1;
	
	private final String DATE_TIME_STRING_FORMAT = "%02d-%02d-%02dT%02d:%02d";
	
	private final int HOUR_MAX = 23;
	private final int MINUTE_MAX = 59;
	
	/* -------------------|
	 * EXCEPTION MESSAGES |
	 * -------------------|
	 * Messages which are feedbacked to the user when exceptions are thrown, personalized to the exception it is referencing.
	 */
	private final String ERROR_MESSAGE_NO_TASK_NAME = "Command: \"%s\" requires a Task Name.";
	private final String ERROR_MESSAGE_NO_TASK_ID = "Command: \"%s\" requires a TaskID number.";
	private final String ERROR_MESSAGE_NO_SEARCH_STRING = "Command: \"%s\" requires a search string.";
	private final String ERROR_MESSAGE_NO_LABEL_NAME_OR_COLOUR = "Command: \"%s\" requires a label name or colour.";
	private final String ERROR_MESSAGE_NO_LABEL_NAME = "Command: \"%s\" requires a label name.";
	private final String ERROR_MESSAGE_NO_DIRECTORY_PATH = "Command: \"%s\" requires a directory path.";
	private final String ERROR_MESSAGE_NEEDS_ONLY_MAIN_COMMAND = "Command: \"%s\" should not be followed by any parameters.";
	private final String ERROR_MESSAGE_COMMAND_NOT_RECOGNISED = "Command: \"%s\" not recognised.";
	private final String ERROR_MESSAGE_EXTENDED_COMMAND_NOT_RECOGNISED = "Extended Command: \"%s\" not recognised.";
	private final String ERROR_MESSAGE_FROM_WITHOUT_TO = "\"FROM\" must be accompanied with \"TO\".";
	private final String ERROR_MESSAGE_DATE_TIME_NOT_RECOGNISED = "Date/Time input: \"%s\" not recognised.";
	private final String ERROR_MESSAGE_COLOUR_NOT_RECOGNISED = "Label Colour: \"%s\" invalid.";
	
	/* -------|
	 * LOGGER |
	 * -------|
	 */
	private static final Logger LOGGER = Logger.getLogger(Parser.class.getName());
	
	/*
	 * -----------------|
	 * TIMEPARSER CLASS |
	 * -----------------|
	 * Class that can parse "natural language" inputs for date and time.
	 */
	private TimeParser timeParser = new TimeParser();
	
	public Parser() {}

	/* ------------|
	 * MAIN METHOD |
	 * ------------|
	 * The main method that other components use. Returns an InputStruct containing the variables of the user input.
	 */
	public InputStruct parseInput(String userInput) throws Exception {
		
		assert(userInput != null); // Not null string.
		assert(userInput.trim() != ""); // Not whitespace String.
		
		String[] splitUserInput = userInput.split(SPACE_STRING);
		String mainCommand = getCommandString(splitUserInput);
		switch (mainCommand) {
			case Constants.STRING_ADD :
				if (!isCommandOnly(splitUserInput)) {
					InputStruct addStruct = getStruct(splitUserInput, EXTENDED_COMMANDS_ADD);
					// Initialises the field in InputStruct which specifies which task type the added task is.
					addStruct.checkAndSetTaskType();
					return addStruct;
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_TASK_NAME, mainCommand)));
				break;
			case Constants.STRING_EDIT :
				if (isNumber(getMainCommandUserInputString(splitUserInput))) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_EDIT);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_TASK_ID, mainCommand)));
				break;
			case Constants.STRING_DELETE :
				if (isNumber(getMainCommandUserInputString(splitUserInput))) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_NIL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_TASK_ID, mainCommand)));
				break;
			case Constants.STRING_SEARCH :
				if (!isCommandOnly(splitUserInput)) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_NIL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_SEARCH_STRING, mainCommand)));
				break;
			case Constants.STRING_DONE :
				if (isNumber(getMainCommandUserInputString(splitUserInput))) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_NIL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_TASK_ID, mainCommand)));
				break;
			case Constants.STRING_RETURN :
				if (isNumber(getMainCommandUserInputString(splitUserInput))) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_NIL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_TASK_ID, mainCommand)));
				break;
			case Constants.STRING_EDITLABEL :
				if (!isCommandOnly(splitUserInput)) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_EDITLABEL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_LABEL_NAME_OR_COLOUR, mainCommand)));
				break;
			case Constants.STRING_DELETELABEL :
				if (!isCommandOnly(splitUserInput)) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_NIL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_LABEL_NAME, mainCommand)));
				break;
			case Constants.STRING_CHECKCONFLICT :
				if (isNumber(getMainCommandUserInputString(splitUserInput))) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_NIL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_TASK_ID, mainCommand)));
				break;
			case Constants.STRING_CHANGEDIR :
				if (!isCommandOnly(splitUserInput)) {
					return getStruct(splitUserInput, EXTENDED_COMMANDS_NIL);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NO_DIRECTORY_PATH, mainCommand)));
				break;
			case Constants.STRING_CHECKDIR :
				if (isCommandOnly(splitUserInput)) {
					return new InputStruct(Constants.STRING_CHECKDIR);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NEEDS_ONLY_MAIN_COMMAND, mainCommand)));
				break;
			case Constants.STRING_UNDOTASK :
				if (isCommandOnly(splitUserInput)) {
					return new InputStruct(Constants.STRING_UNDOTASK);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NEEDS_ONLY_MAIN_COMMAND, mainCommand)));
				break;
			case Constants.STRING_HELP :
				if (isCommandOnly(splitUserInput)) {
					return new InputStruct(Constants.STRING_HELP);
				}
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_NEEDS_ONLY_MAIN_COMMAND, mainCommand)));
				break;
			default :
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_COMMAND_NOT_RECOGNISED, mainCommand)));
				break;
		}
		return null;
	}
	
	/* ---------------------------|
	 * MAIN METHOD HELPER METHODS |
	 * ---------------------------|
	 */
	
	private String getCommandString(String[] userInputStringArray) {
		return userInputStringArray[INDEX_MAIN_COMMAND];
	}
	
	private String getMainCommandUserInputString(String[] splitUserInput) {
		if (splitUserInput.length < LENGTH_OF_COMMAND_WITH_USER_INPUT) {
			return null;
		}
		return splitUserInput[INDEX_MAIN_COMMAND_USER_INPUT];
	}
	
	private boolean isCommandOnly(String[] splitUserInput) {
		return splitUserInput.length == LENGTH_OF_COMMAND_ONLY_MAIN_COMMAND;
	}
	
	private boolean isNumber(String input) {
		if (input == EMPTY_STRING || input == null) {
			return false;
		}
		boolean isNumber = true;
		for (int i = 0; i < input.length(); i++) {
			if (!Character.isDigit(input.charAt(i))) {
				isNumber = false;
				break;
			}
		}
		return isNumber;
	}

	/* -----------------|
	 * GETSTRUCT METHOD |
	 * -----------------|
	 * Parses the user input, detects and stores the variables in the user input and puts it in the appropriate InputStruct field.
	 */
	private InputStruct getStruct(String[] splitUserInput, String[] extendedCommands) throws Exception {
		
		String mainCommand = getCommandString(splitUserInput);
		
		// Creates the InputStruct to be returned.
		InputStruct currInputStruct = new InputStruct(mainCommand);

		String currCommand = mainCommand;

		// userInputString is the string currently being read. While an extended command is not found, words are added to this String.
		String currInputString = EMPTY_STRING;

		for (int i = 1; i < splitUserInput.length; i++) {
			String currString = splitUserInput[i];
			if (isExtendedCommand(currString, extendedCommands)) { // Word being read is an extended command.
				if (currCommand == mainCommand) {
					parseMainCommand(currInputStruct, currCommand, currInputString.trim());
				} else {
					parseExtendedCommand(mainCommand, currCommand, currInputString.trim(), currInputStruct);
				}
				currCommand = currString; // Updates the current command.
				currInputString = EMPTY_STRING; // Resets "userInputString" as it is already parsed.
			} else { // Updates the current input string if word being read is not an extended command.
				currInputString += currString + SPACE_STRING;
			} 
		}
		//Parses the last user input string which is not covered in the while loop above.
		if (currCommand == mainCommand) {
			parseMainCommand(currInputStruct, currCommand, currInputString.trim());
		} else {
			parseExtendedCommand(mainCommand, currCommand, currInputString.trim(), currInputStruct);
		}
		return currInputStruct;
	}
	
	// Checks if input string is an extended command of the main command.
	private boolean isExtendedCommand(String input, String[] extendedCommands) {
		for (int i = 0; i < extendedCommands.length; i++) {
			if (input.equals(extendedCommands[i])) {
				return true;
			}
		}
		return false;
	}
	
	
	/* -------------------------|
	 * EXTENDED COMMAND PARSERS |
	 * -------------------------|
	 */
	
	//Used due to the "ADD" command requiring a different way of parsing the first user input.
	private void parseMainCommand(InputStruct currInputStruct, String currCommand, String currInputString) {
		if (currCommand.equals(Constants.STRING_ADD)) {
			currInputStruct.setAtIndex(Constants.INDEX_NAME, currInputString);
		} else {
			currInputStruct.setAtIndex(Constants.INDEX_BASE, currInputString);
		}
	}
	
	// Uses the extended command method which is appropriate to the main command. (Different main commands have different extended commands.) 
	private void parseExtendedCommand(String mainCommand, String extendedCommand, String inputString, InputStruct inputStruct) throws Exception {
		switch (mainCommand) {
			case Constants.STRING_ADD :
				parseExtendedCommandAdd(extendedCommand, inputString, inputStruct);
				break;
			case Constants.STRING_EDIT :
				parseExtendedCommandEdit(extendedCommand, inputString, inputStruct);
				break;
			case Constants.STRING_EDITLABEL :
				parseExtendedCommandEditLabel(extendedCommand, inputString, inputStruct);
				break;
			default:
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_EXTENDED_COMMAND_NOT_RECOGNISED, extendedCommand)));
				break;
		}
	}
	
	// Parses extended commands for "ADD".
	private void parseExtendedCommandAdd(String extendedCommand, String inputString, InputStruct inputStruct) throws Exception {
		switch (extendedCommand) {
			case Constants.STRING_DESC :
				setDescription(inputString, inputStruct);
				break;
			case Constants.STRING_AT :
			case Constants.STRING_ON :
			case Constants.STRING_FROM :
			case Constants.STRING_BY :
				setTime(extendedCommand, inputString, inputStruct);
				break;
			case Constants.STRING_LABEL :
				setCategory(inputString, inputStruct);
				break;
			default :
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_EXTENDED_COMMAND_NOT_RECOGNISED, extendedCommand)));
		}
	}
	
	// Parses extended commands for "EDIT".
	private void parseExtendedCommandEdit(String extendedCommand, String inputString, InputStruct inputStruct) throws Exception {
		switch (extendedCommand) {
			case Constants.STRING_NAME :
				setName(inputString, inputStruct);
				break;
			case Constants.STRING_DESC :
				setDescription(inputString, inputStruct);
				break;
			case Constants.STRING_TIME :
				String dateTimeExtendedCommand = getCommandString(inputString.split(SPACE_STRING));
				setTime(dateTimeExtendedCommand, inputString.substring(dateTimeExtendedCommand.length() + INCREMENT_BY_1), inputStruct);
				break;
			case Constants.STRING_LABEL :
				setCategory(inputString, inputStruct);
				break;
			default :
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_EXTENDED_COMMAND_NOT_RECOGNISED, extendedCommand)));
		}
	}
	
	private void setName(String userInput, InputStruct inputStruct) {
		inputStruct.setAtIndex(Constants.INDEX_NAME, userInput);
	}
	
	private void setDescription(String userInput, InputStruct inputStruct) {
		inputStruct.setAtIndex(Constants.INDEX_DESCRIPTION, userInput);
	}
	
	// Parses the extended commands for time which each functions differently.
	private void setTime(String extendedCommand, String userInput, InputStruct inputStruct) throws Exception {
		switch (extendedCommand) {
			case Constants.STRING_AT :
				parseAt(userInput, inputStruct);
				break;
			case Constants.STRING_ON :
				parseOn(userInput, inputStruct);
				break;
			case Constants.STRING_FROM :
				parseFrom(userInput, inputStruct);
				break;
			case Constants.STRING_BY :
				parseBy(userInput, inputStruct);
				break;
			default :
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_DATE_TIME_NOT_RECOGNISED, extendedCommand)));
		}
	}
	
	/* AT
	 * Date and time set: 1hr from specified date and time.
	 * No time set: 1 hr from start of specified date.
	 * No date set: 1 hr from next instance of specified time.
	 */
	private void parseAt(String userInput, InputStruct inputStruct) throws Exception {
		Calendar parsedCalendar = timeParser.parseTime(Constants.STRING_AT, userInput);
		inputStruct.setAtIndex(Constants.INDEX_FROM, calendarToStringFormat(parsedCalendar));
		parsedCalendar.add(Calendar.HOUR_OF_DAY, 1);
		inputStruct.setAtIndex(Constants.INDEX_TO, calendarToStringFormat(parsedCalendar));
	}

	/* ON
	 * Date and time set: Specified date and time to end of that day.
	 * No time set: Start of specified date to end of that day.
	 * No date set: Next instance of specified time to end of that day.
	 */ 
	void parseOn(String userInput, InputStruct inputStruct) throws Exception {
		Calendar parsedCalendar = timeParser.parseTime(Constants.STRING_ON, userInput);
		inputStruct.setAtIndex(Constants.INDEX_FROM, calendarToStringFormat(parsedCalendar));
		parsedCalendar.set(Calendar.HOUR_OF_DAY, HOUR_MAX);
		parsedCalendar.set(Calendar.MINUTE, MINUTE_MAX);
		inputStruct.setAtIndex(Constants.INDEX_TO, calendarToStringFormat(parsedCalendar));
	}
	
	/* FROM (needs to be followed by TO)
	 * Date and time set: Specified start date and time to specified end time.
	 * No time set: Start of day of specified start date to end of day of specified end date.
	 * No date set: Next instance of specified start time to next instance of specified end time after that.
	 */
	private void parseFrom(String userInput, InputStruct inputStruct) throws Exception {
		if (!userInput.contains(" TO ")) {
			logAndThrow(new MissingDateTimeFieldException(ERROR_MESSAGE_FROM_WITHOUT_TO));
		} else {
			String[] splitFromTo = userInput.split(" TO ");
			Date from = timeParser.parseTime(Constants.STRING_FROM, splitFromTo[0]).getTime();
			inputStruct.setAtIndex(Constants.INDEX_FROM, calendarToStringFormat(timeParser.parseTime(Constants.STRING_FROM, splitFromTo[0])));
			Calendar to = timeParser.parseTime(Constants.STRING_TO, splitFromTo[1]);
			while (!isAfterFromDate(from, to)) {
				to.add(Calendar.DATE, INCREMENT_BY_1);
			}
			inputStruct.setAtIndex(Constants.INDEX_TO, calendarToStringFormat(to));
		}
	}
	
	/* BY
	 * Date and time set: Deadline by specified date and time.
	 * No time set: Deadline by end of day of specified date.
	 * No date set: Deadline by next instance of specified time.
	 */
	private void parseBy(String userInput, InputStruct inputStruct) throws Exception {
		inputStruct.setAtIndex(Constants.INDEX_FROM, calendarToStringFormat(timeParser.parseTime(Constants.STRING_BY, userInput)));
	}
	
	private void setCategory(String userInput, InputStruct inputStruct) {
		inputStruct.setAtIndex(Constants.INDEX_LABEL, userInput);
	}
	
	// Parses extended commands for "EDITLABEL".
	private void parseExtendedCommandEditLabel(String extendedCommand, String inputString, InputStruct inputStruct) throws Exception {
		switch (extendedCommand) {
			case Constants.STRING_NAME :
				setLabelName(inputString, inputStruct);
				break;
			case Constants.STRING_COLOUR :
				setLabelColour(inputString.toLowerCase(), inputStruct);
				break;
			default :
				logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_EXTENDED_COMMAND_NOT_RECOGNISED, extendedCommand)));
		}
	}
	
	private void setLabelName(String userInput, InputStruct inputStruct) {
		inputStruct.setAtIndex(Constants.INDEX_EDITLABEL_NAME, userInput);
	}
	
	private void setLabelColour(String userInput, InputStruct inputStruct) throws Exception {
		if (isValidColour(userInput)) {
			inputStruct.setAtIndex(Constants.INDEX_EDITLABEL_COLOUR, userInput);
		} else {
			logAndThrow(new InvalidCommandException(String.format(ERROR_MESSAGE_COLOUR_NOT_RECOGNISED, userInput)));
		}
	}
	
	private boolean isValidColour(String input) {
		for (int i = 0; i < VALID_COLOURS.length; i++) {
			if (input.equals(VALID_COLOURS[i])) {
				return true;
			}
		}
		return false; 
	}
	
	private String calendarToStringFormat(Calendar parsedCalendar) {
		Date parsedDate = parsedCalendar.getTime();
		int year = parsedDate.getYear() + OFFSET_CALENDAR_YEAR;
		int date = parsedDate.getDate();
		int month = parsedDate.getMonth() + OFFSET_CALENDAR_MONTH;
		int hours = parsedDate.getHours();
		int minutes = parsedDate.getMinutes();
		String outputDate = String.format(DATE_TIME_STRING_FORMAT, year, month, date, hours, minutes);
		return outputDate;
	}
	
	// Checks if time of input Date is after time of input Calendar.
	private boolean isAfterFromDate(Date inputFrom, Calendar inputTo) {
		boolean case1 = inputFrom.getMonth() < inputTo.get(Calendar.MONTH);
		boolean case2 = inputFrom.getMonth() == inputTo.get(Calendar.MONTH) && inputFrom.getDate() < inputTo.get(Calendar.DAY_OF_MONTH);
		boolean case3 = inputFrom.getMonth() == inputTo.get(Calendar.MONTH) && inputFrom.getDate() == inputTo.get(Calendar.DAY_OF_MONTH);
		if (case3) {
			boolean case4 = inputFrom.getHours() < inputTo.get(Calendar.HOUR_OF_DAY);
			boolean case5 = inputFrom.getHours() == inputTo.get(Calendar.HOUR_OF_DAY) && inputFrom.getMinutes() < inputTo.get(Calendar.MINUTE);
			return case4 || case5;
		}
		return case1 || case2;
	}
	
	public void logAndThrow(Exception e) throws Exception {
        LOGGER.log(Level.WARNING, e.getMessage());
        throw e;
    }

}
```
###### \src\org\jimple\planner\parser\TimeParser.java
``` java

package org.jimple.planner.parser;

import java.util.Calendar;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.jimple.planner.constants.Constants;

import org.jimple.planner.exceptions.DuplicateDateTimeFieldException;
import org.jimple.planner.exceptions.InvalidDateTimeFieldException;
import org.jimple.planner.exceptions.MissingDateTimeFieldException;

public class TimeParser {
	
	/* -----------------------------------|
	 * TIMEPARSER MISCELLANEOUS CONSTANTS |
	 * -----------------------------------|
	 */
	// AMPM constants
	private final int AMPM_HOURS_MIN = 0;
	private final int AMPM_HOURS_MAX = 12;
	private final String AMPM_FLOATING_NUMBER_MINUTE = "0";
	private final int TIME_FIELDS_SIZE = 2;
	private final int AMPM_INPUT_MIN_LENGTH = 3;
	private final int OFFSET_PM_HOURS = 12;
	private final int OFFSET_LAST_2_CHARACTERS = 2;
	private final String STRING_PM = "pm";
	private final String STRING_AM = "am";
	private final String STRING_DOT = ".";
	
	// Natural language days constants
	private final String STRING_TOMORROW = "tomorrow";
	private final String STRING_TODAY = "today";
	
	// Forward slash date format constants
	private final int DAY_MONTH_YEAR_FORMAT_LENGTH = 3;
	private final int DAY_MONTH_FORMAT_LENGTH = 2;
	private final int INDEX_DAY = 0;
	private final int INDEX_MONTH = 1;
	private final int INDEX_YEAR = 2;
	
	// 4-digit time format constants
	private final int OFFSET_NOT_4_DIGIT_YEAR = 2000;
	private final int MIN_4_DIGIT_YEAR = 1000;
	private final int INDEX_SEPARATE_4_DIGIT_HOUR_MINUTE = 2;
	private final int FORMAT_LENGTH_4_DIGIT = 4;
	
	// Date constants
	private final String STRING_FORWARD_SLASH = "/";
	private final int OFFSET_CALENDAR_MONTH = 1;
	private final int MONTH_MAX = 12;
	private final int MONTH_MIN = 1;
	
	// Time constants
	private final String STRING_COLON = ":";
	private final String STRING_DOT_FOR_SPLIT = "\\.";
	private final int INDEX_HOUR = 0;
	private final int INDEX_MINUTE = 1;
	
	private final int HOUR_MAX = 23;
	private final int HOUR_MIN = 0;
	private final int MINUTE_MAX = 59;
	private final int MINUTE_MIN = 0;
	
	// General constants
	private final int START_INDEX = 0;
	private final int INCREMENT_BY_1 = 1;
	private final String EMPTY_STRING = "";
	private final String SPACE_STRING = " ";
	
	/* ----------------------------|
	 * TIMEPARSER PARSER CONSTANTS |
	 * ----------------------------|
	 * Constants which are only used in TimeParser.
	 */
	
	// Array of accepted non-number month inputs.
	private String[] STRINGS_MONTH = {"january", "jan",
			"february", "feb",
			"march", "mar",
			"april", "apr",
			"may",
			"june", "jun",
			"july", "jul",
			"august", "aug",
			"september", "sep",
			"october", "oct",
			"november", "nov",
			"december", "dec"};
	
	// Array of month numbers associated with the same index in the STRINGS_MONTH array.
	private int[] VALUES_MONTH = {
			1, 1,
			2, 2,
			3, 3,
			4, 4,
			5,
			6, 6,
			7, 7,
			8, 8,
			9, 9,
			10, 10,
			11, 11,
			12, 12};
	
	// Array of accepted day-of-week inputs.
	private String[] STRINGS_DAY = {"sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"};
	
	// Array of day numbers associated with the same index in the STRINGS_DAY array.
	private int[] VALUES_DAY = {1, 2, 3, 4, 5, 6, 7};
	
	/* ---------|
	 * HASHMAPS |
	 * ---------|
	 * HashMaps to easily access the month/day numbers from their respective strings.
	 */
	private HashMap<String, Integer> calendarMonths = new HashMap<String, Integer>();
	private HashMap<String, Integer> calendarDays = new HashMap<String, Integer>();
	
	/* ------------------------|
	 * TIMEPARSER ERROR VALUES |
	 * ------------------------|
	 * Constants used to depict an error. Used by TimeParser functions to return and detect errors.
	 */
	private final int FIELD_NOT_SET_VALUE = -1;
	private final int FIELD_INVALID_VALUE = -2;
	
	private final String ERROR_MESSAGE_UNRECOGNISED_DATE_TIME = "Date/Time: \"%s\" not recognised.";
	private final String ERROR_MESSAGE_FIELD_NOT_SET = "Field: %s not set.";
	private final String ERROR_MESSAGE_FIELD_ALREADY_SET = "%s cannot be set to %s. %s already set to %s.";
	private final String ERROR_MESSAGE_INVAID_AMPM_FORMAT = "Invalid time AM/PM format: \"%s\".";
	private final String ERROR_MESSAGE_AMPM_DOT_FORMAT = "Invalid input: \"%s\". Time should be formated to hh.mm before am/pm.";
	private final String ERROR_MESSAGE_AMPM_COLON_FORMAT = "Invalid input: \"%s\". Time should be formated to hh:mm before am/pm.";
	private final String ERROR_MESSAGE_PARSE_AMPM_HOUR = "Invalid input: Hour \"%s\" of \"%s\". Please input a valid AM/PM time for hour.";
	private final String ERROR_MESSAGE_DOT_FORMAT = "Invalid input: \"%s\". Time should be written in \"hh.mm\" format.";
	private final String ERROR_MESSAGE_COLON_FORMAT = "Invalid input: \"%s\". Time should be written in \"hh:mm\" format."; 
	private final String ERROR_MESSAGE_FORWARD_SLASH_FORMAT = "Invalid input: \"%s\". Time should be written in \"dd/mm\" or \"dd/mm/yyyy\" format.";
	private final String ERROR_MESSAGE_PARSE_DAY = "Invalid input: Day \"%s\" of \"%s\". Please input a valid time for day.";
	private final String ERROR_MESSAGE_PARSE_MONTH = "Invalid input: Day \"%s\" of \"%s\". Please input a valid time for day.";
	private final String ERROR_MESSAGE_PARSE_YEAR = "Invalid input: Day \"%s\" of \"%s\". Please input a valid time for day.";
	private final String ERROR_MESSAGE_YEAR_PAST = "Invalid input: Year \"%s\" of \"%s\" is before the current year.";
	private final String ERROR_MESSAGE_PARSE_HOUR = "Invalid input: Day \"%s\" of \"%s\". Please input a valid time for day.";
	private final String ERROR_MESSAGE_PARSE_MINUTE = "Invalid input: Day \"%s\" of \"%s\". Please input a valid time for day.";
	//private final String ERROR_MESSAGE_DATE_PAST = "Invalid input: Date \"%s\" is before the current date.";
	
	/* ----------------------------|
	 * TIMEPARSER DATE/TIME FIELDS |
	 * ----------------------------|
	 * Temporary variables which store the parsed date/time fields. These variables will be entered into the output Calendar. 
	 */
	private int day = FIELD_NOT_SET_VALUE;
	private int month = FIELD_NOT_SET_VALUE;
	private int year = FIELD_NOT_SET_VALUE;
	private int hour = FIELD_NOT_SET_VALUE;
	private int minute = FIELD_NOT_SET_VALUE;
	
	private final String FIELD_YEAR = "year";
	private final String FIELD_MONTH = "month";
	private final String FIELD_DAY = "day";
	private final String FIELD_HOUR = "hour";
	private final String FIELD_MINUTE = "minute";
	
	/* ---------|
	 * CALENDAR |
	 * ---------|
	 * The main java data structure used to calculate date/time.
	 */
	private Calendar c = null;
	
	/* -------|
	 * LOGGER |
	 * -------|
	 */
	private static final Logger LOGGER = Logger.getLogger(TimeParser.class.getName());
	
	/* -----------------------|
	 * TIMEPARSER CONSTRUCTOR |
	 * -----------------------|
	 * Sets up the hashmaps for easy access.
	 */
	public TimeParser() {
		for (int i = 0; i < STRINGS_MONTH.length; i++) {
			calendarMonths.put(STRINGS_MONTH[i], VALUES_MONTH[i]);
		}
		for (int i = 0; i < STRINGS_DAY.length; i++) {
			calendarDays.put(STRINGS_DAY[i], VALUES_DAY[i]);
		}
	}
	
	/* -------------------|
	 * MAIN PARSER METHOD |
	 * -------------------|
	 * Takes in a string and returns the Calendar with the specified date/time. If there is an error, returns null.
	 */
	public Calendar parseTime(String extendedCommand, String input) throws Exception {
		resetTimeAndDate();
		String[] splitInput = input.split(SPACE_STRING);
		for (String i: splitInput) { // For each word being read, goes through a list of parsers which is then converted to the appropriate date/time to be stored in calendar.
			if (parseIfIsDay(i)) {
			} else if (parseIfIsMonth(i)) {
			} else if (parseIfIsAMPMFormat(i)) {
			} else if (parseIfIsTodayOrTomorrow(i)) {
			} else if (parseIfIsColonTimeFormat(i)) {
			} else if (parseIfIsDotTimeFormat(i)) {
			} else if (parseIfIsForwardSlashDateFormat(i)) {
			} else if (parseIfIs4DigitFloatingNumber(i)) {
			} else if (parseIfIs2OrLessDigitFloatingNumber(i)) {
			} else {  // All parsers failed, word being read not recognised.
				logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_UNRECOGNISED_DATE_TIME, i)));
			}
		}
		if (!formatCalendarIfValid(extendedCommand, input)) {
			return null;
		}
		return c;
	}

	/* -------------------------|
	 * CALENDAR VERIFIER METHOD |
	 * -------------------------|
	 * After parsing through the entire input string, checks if all the required fields are specified.
	 */
	private boolean formatCalendarIfValid(String extendedCommand, String userInput) throws Exception {
		c = Calendar.getInstance(); // Initialises the Calendar.
		initSecondaryAndPresetFields(extendedCommand);
		// Set up fields in calendar according to parsed inputs.
		if (setCalendarField(FIELD_HOUR, getField(FIELD_HOUR))) {
			if (setCalendarField(FIELD_MINUTE, getField(FIELD_MINUTE))) {
				if (setCalendarField(FIELD_YEAR, getField(FIELD_YEAR))) {
					if (setCalendarField(FIELD_MONTH, getField(FIELD_MONTH))) {
						if (setCalendarField(FIELD_DAY, getField(FIELD_DAY))) {
							return true;
						}
					}
				}
			}
		}
		return false; // If any fields are missing, parsing has failed, return false.
	}

```
###### \src\org\jimple\planner\parser\TimeParser.java
``` java
	/* -----------------------------------|
	 * DATE/TIME INPUT FLEXIBILITY METHOD |
	 * -----------------------------------|
	 * The TimeParser allows users to input:
	 * - Date & Time
	 * - Date only
	 * - Time only
	 * This method detects which of the above the current user input is, then fills in certain empty fields (if applicable) according to the extended command used.
	 */
	private boolean initSecondaryAndPresetFields(String extendedCommand) throws Exception {
		if (isTimeOnly()) {
			setDateToNextInstanceOfSpecifiedTime();
		}
		if (isMissingTime()) {
			setTimeAccordingToExtendedCommand(extendedCommand);
		}
		if (!isFieldSet(FIELD_YEAR)) {
			setYearToNextInstanceOfSpecifiedDateTime();
		}
		c.set(Calendar.SECOND, 0); // Seconds preset to 0 (default).
		return true;
	}

	// Increments year by 1 if specified date is before current date.
	private void setYearToNextInstanceOfSpecifiedDateTime() throws Exception {
		c.setTimeInMillis(System.currentTimeMillis());
		if (!isAfterCurrentDate(getField(FIELD_DAY), getField(FIELD_MONTH)) && !isToday(getField(FIELD_DAY), getField(FIELD_MONTH))) {
			c.add(Calendar.YEAR, INCREMENT_BY_1);
			setField(FIELD_YEAR, c.get(Calendar.YEAR));
		} else {
			setField(FIELD_YEAR, c.get(Calendar.YEAR));
		}
	}

	/* Time will be set according to their extended command:
	 * ON/AT/FROM: 00:00
	 * TO/BY: 23:59
	 */
	private void setTimeAccordingToExtendedCommand(String extendedCommand) throws Exception {
		switch (extendedCommand) {
			case Constants.STRING_ON :
			case Constants.STRING_AT :
			case Constants.STRING_FROM :
				setField(FIELD_HOUR, HOUR_MIN);
				setField(FIELD_MINUTE, MINUTE_MIN);
				break;
			case Constants.STRING_TO :
			case Constants.STRING_BY :
				setField(FIELD_HOUR, HOUR_MAX);
				setField(FIELD_MINUTE, MINUTE_MAX);
				break;
			default :
				break;
		}
	}

	// Increments date by 1 if specified time is before current time.
	private void setDateToNextInstanceOfSpecifiedTime() throws Exception {
		c.setTimeInMillis(System.currentTimeMillis());
		if (!isAfterCurrentTime(getField(FIELD_HOUR), getField(FIELD_MINUTE))) {
			c.add(Calendar.DATE, INCREMENT_BY_1);
		}
		setField(FIELD_DAY, c.get(Calendar.DAY_OF_MONTH));
		setField(FIELD_MONTH, c.get(Calendar.MONTH) + OFFSET_CALENDAR_MONTH);
		setField(FIELD_YEAR, c.get(Calendar.YEAR));
	}

	private boolean isMissingTime() {
		return !isFieldSet(FIELD_HOUR) && !isFieldSet(FIELD_MINUTE);
	}

	private boolean isTimeOnly() {
		return isFieldSet(FIELD_HOUR) && isFieldSet(FIELD_MINUTE) && !isFieldSet(FIELD_DAY) && !isFieldSet(FIELD_MONTH) && !isFieldSet(FIELD_YEAR);
	}
	
	private boolean isToday(int inputDay, int inputMonth) {
		c.setTimeInMillis(System.currentTimeMillis());
		return inputMonth == c.get(Calendar.MONTH) + OFFSET_CALENDAR_MONTH && inputDay == c.get(Calendar.DAY_OF_MONTH);
	}
	
	// Returns true if input date is after current date. Vice versa.
	private boolean isAfterCurrentDate(int inputDay, int inputMonth) {
		c.setTimeInMillis(System.currentTimeMillis());
		boolean case1 = inputMonth > c.get(Calendar.MONTH) + OFFSET_CALENDAR_MONTH;
		boolean case2 = inputMonth == c.get(Calendar.MONTH) + OFFSET_CALENDAR_MONTH && inputDay > c.get(Calendar.DAY_OF_MONTH);
		return case1 || case2;
	}
	
	// Returns true if input time is after current time. Vice versa.
	private boolean isAfterCurrentTime(int inputHour, int inputMinute) {
		c.setTimeInMillis(System.currentTimeMillis());
		boolean case1 = inputHour > c.get(Calendar.HOUR_OF_DAY);
		boolean case2 = inputHour == c.get(Calendar.HOUR_OF_DAY) && inputMinute > c.get(Calendar.MINUTE);
		return case1 || case2;
	}
	
	private boolean resetTimeAndDate() {
		day = FIELD_NOT_SET_VALUE;
		month = FIELD_NOT_SET_VALUE;
		year = FIELD_NOT_SET_VALUE;
		hour = FIELD_NOT_SET_VALUE;
		minute = FIELD_NOT_SET_VALUE;
		return true;
	}
	
	/* ------------------------------|
	 * SETTERS, CHECKERS AND GETTERS |
	 * ------------------------------|
	 */
	// Fields set here are the output Calendar fields.
	private boolean setCalendarField(String inputField, int inputValue) throws Exception {
		if (!isFieldSet(inputField)) {
			logAndThrow(new MissingDateTimeFieldException(String.format(ERROR_MESSAGE_FIELD_NOT_SET, inputField)));
		} else {
			switch (inputField) {
				case FIELD_DAY :
					c.set(Calendar.DAY_OF_MONTH, inputValue);
					return true;
				case FIELD_MONTH :
					c.set(Calendar.MONTH, inputValue-1);
					return true;
				case FIELD_YEAR :
					c.set(Calendar.YEAR, inputValue);
					return true;
				case FIELD_HOUR :
					c.set(Calendar.HOUR_OF_DAY, inputValue);
					return true;
				case FIELD_MINUTE :
					c.set(Calendar.MINUTE, inputValue);
					return true;
				default :
					break;
			}
		}
		return false;
	}
	
	// Fields being set here are the temporary fields, not the output Calendar fields.
	private boolean setField(String inputField, int inputValue) throws Exception {
		if (isFieldSet(inputField)) {
			logAndThrow(new DuplicateDateTimeFieldException(String.format(ERROR_MESSAGE_FIELD_ALREADY_SET, inputField, inputValue, inputField, getField(inputField))));
		} else {
			switch (inputField) {
				case FIELD_DAY :
					day = inputValue;
					return true;
				case FIELD_MONTH :
					month = inputValue;
					return true;
				case FIELD_YEAR :
					year = inputValue;
					return true;
				case FIELD_HOUR :
					hour = inputValue;
					return true;
				case FIELD_MINUTE :
					minute = inputValue;
					return true;
				default :
					break;
			}
		}
		return false;
	}
	
	// Fields being checked here are the temporary fields, not the output Calendar fields.
	private boolean isFieldSet(String inputField) {
		switch (inputField) {
			case FIELD_DAY :
				return day != FIELD_NOT_SET_VALUE;
			case FIELD_MONTH :
				return month != FIELD_NOT_SET_VALUE;
			case FIELD_YEAR :
				return year != FIELD_NOT_SET_VALUE;
			case FIELD_HOUR :
				return hour != FIELD_NOT_SET_VALUE;
			case FIELD_MINUTE :
				return minute != FIELD_NOT_SET_VALUE;
			default :
				return true;
		}
	}
	
	// Fields being retrieved here are the temporary fields, not the output Calendar fields.
	private int getField(String inputField) {
		switch (inputField) {
			case FIELD_DAY :
				return day;
			case FIELD_MONTH :
				return month;
			case FIELD_YEAR :
				return year;
			case FIELD_HOUR :
				return hour;
			case FIELD_MINUTE :
				return minute;
			default :
				return FIELD_INVALID_VALUE;
		}
	}
	
	/* ------------------|
	 * DATE/TIME PARSERS |
	 * ------------------|
	 * The parsers detect different cases of date/time inputs which then stores the detected values into the proper date/time variable.
	 */
	
	/*
	 * DAY PARSER
	 * Parses days. E.g Monday, Wednesday, Sunday
	 */
	private boolean parseIfIsDay(String input) throws Exception{
		if (calendarDays.containsKey(input)) {
			c = Calendar.getInstance();
			c.setTimeInMillis(System.currentTimeMillis());
			int inputDayNo = calendarDays.get(input);
			while (c.get(Calendar.DAY_OF_WEEK) != inputDayNo) {
				c.add(Calendar.DATE, INCREMENT_BY_1);
			}
			setField(FIELD_DAY, c.get(Calendar.DATE));
			setField(FIELD_MONTH, c.get(Calendar.MONTH) + OFFSET_CALENDAR_MONTH);
			return true;
		}
		return false;
	}
	
	/*
	 * AMPM PARSER
	 * Parses am and pm. E.g 12am, 5.30pm, 10:25pm.
	 */
	private boolean parseIfIsAMPMFormat(String input) throws NumberFormatException, Exception {
		if (input.length() < AMPM_INPUT_MIN_LENGTH) {
			return false;
		}
		String last2Characters = input.substring(input.length() - OFFSET_LAST_2_CHARACTERS, input.length()).toLowerCase();
		if (last2Characters.equals(STRING_AM) || last2Characters.equals(STRING_PM)) {
			String beforeLast2Characters = input.substring(START_INDEX, input.length() - OFFSET_LAST_2_CHARACTERS);
			if (beforeLast2Characters.contains(STRING_DOT)) {
				return parseDotAMPM(beforeLast2Characters, last2Characters, input);
			} else if (beforeLast2Characters.contains(STRING_COLON)) {
				return parseColonAMPM(beforeLast2Characters, last2Characters, input);
			} else if (isANumber(beforeLast2Characters)){
				return parseFloatingNumberAMPM(beforeLast2Characters, last2Characters, input);
			} else {
				logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_INVAID_AMPM_FORMAT, input)));
			}
		}
		return false;
	}
	
	// E.g 1.30pm, E.g 6.10am, 11.03pm
	private boolean parseDotAMPM(String inputTime, String inputAMPM, String userInput) throws NumberFormatException, Exception {
		String[] splitTime = inputTime.split(STRING_DOT_FOR_SPLIT);
		if (splitTime.length == TIME_FIELDS_SIZE) {
			String inputHour = splitTime[INDEX_HOUR];
			String inputMinute = splitTime[INDEX_MINUTE];
			setAMPMHour(inputHour, inputAMPM, userInput);
			parseMinute(inputMinute, userInput);
			return true;
		}
		logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_AMPM_DOT_FORMAT, inputTime)));
		return false;
	}
	
	// E.g 1:30pm, E.g 6:10am, 6:03pm
	private boolean parseColonAMPM(String inputTime, String inputAMPM, String userInput) throws NumberFormatException, Exception {
		String[] splitTime = inputTime.split(STRING_COLON);
		if (splitTime.length == TIME_FIELDS_SIZE) {
			String inputHour = splitTime[INDEX_HOUR];
			String inputMinute = splitTime[INDEX_MINUTE];
			setAMPMHour(inputHour, inputAMPM, userInput);
			parseMinute(inputMinute, userInput);
			return true;
		}
		logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_AMPM_COLON_FORMAT, inputTime)));
		return false;
	}
	
	private boolean parseFloatingNumberAMPM(String inputTime, String inputAMPM, String userInput) throws NumberFormatException, Exception {
		setAMPMHour(inputTime, inputAMPM, userInput);
		parseMinute(AMPM_FLOATING_NUMBER_MINUTE, userInput);
		return true;
	}

	private void setAMPMHour(String inputHour, String inputAMPM, String userInput) throws NumberFormatException, Exception {
		if (!isANumber(inputHour) || !isValidAMPMHour(inputHour)) {
			logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_PARSE_AMPM_HOUR, inputHour, userInput)));
		} else {
			switch (inputAMPM) {
				case STRING_AM :
					setField(FIELD_HOUR, Integer.parseInt(inputHour) % AMPM_HOURS_MAX);
					break;
				case STRING_PM :
					setField(FIELD_HOUR, (Integer.parseInt(inputHour) % AMPM_HOURS_MAX) + OFFSET_PM_HOURS);
					break;
			}
		}
	}
	
	private boolean isValidAMPMHour(String input) {
		int inputHour = Integer.parseInt(input);
		return inputHour > AMPM_HOURS_MIN && inputHour <= AMPM_HOURS_MAX;
	}
	
	// Parses the words "today" and "tomorrow".
	private boolean parseIfIsTodayOrTomorrow(String input) throws Exception{
		c = Calendar.getInstance();
		switch (input.toLowerCase()) {
		case STRING_TODAY :
			setField(FIELD_DAY, c.get(Calendar.DATE));
			setField(FIELD_MONTH, c.get(Calendar.MONTH) + OFFSET_CALENDAR_MONTH);
			return true;
		case STRING_TOMORROW :
			c.add(Calendar.DATE, INCREMENT_BY_1);
			setField(FIELD_DAY, c.get(Calendar.DATE));
			setField(FIELD_MONTH, c.get(Calendar.MONTH) + OFFSET_CALENDAR_MONTH);
			return true;
		default :
			break;
		}
		return false;
	}

	// Parses months. E.g February, May, December.
	private boolean parseIfIsMonth(String input) throws Exception {
		String inputLowerCase = input.toLowerCase();
		if (calendarMonths.containsKey(inputLowerCase)) {
			setField(FIELD_MONTH, calendarMonths.get(inputLowerCase));
			return true;
		}
		return false;
	}

	// Parses time in hh:mm format. E.g 00:00, 12:34, 23:59.
	private boolean parseIfIsColonTimeFormat(String input) throws NumberFormatException, Exception {
		if (input.contains(STRING_COLON)) {
			String[] splitTime = input.split(STRING_COLON);
			if (splitTime.length == TIME_FIELDS_SIZE) {
				String inputHour = splitTime[INDEX_HOUR];
				String inputMinute = splitTime[INDEX_MINUTE];
				parseHour(inputHour, input);
				parseMinute(inputMinute, input);
				return true;
			} else {
				logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_COLON_FORMAT, input)));
			}
		}
		return false;
	}
	
	private boolean parseIfIsDotTimeFormat(String input) throws NumberFormatException, Exception {
		if (input.contains(STRING_DOT_FOR_SPLIT)) {
			String[] splitTime = input.split(STRING_DOT_FOR_SPLIT);
			if (splitTime.length == TIME_FIELDS_SIZE) {
				String inputHour = splitTime[INDEX_HOUR];
				String inputMinute = splitTime[INDEX_MINUTE];
				parseHour(inputHour, input);
				parseMinute(inputMinute, input);
				return true;
			} else {
				logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_DOT_FORMAT, input)));
			}
		}
		return false;
	}

	private void parseMinute(String inputMinute, String userInput) throws NumberFormatException, Exception {
		if (!isANumber(inputMinute) || !isValidMinute(inputMinute)) {
			logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_PARSE_MINUTE, inputMinute, userInput)));
		} else {
			setField(FIELD_MINUTE, Integer.parseInt(inputMinute));
		}
	}

	private void parseHour(String inputHour, String userInput) throws NumberFormatException, Exception {
		if (!isANumber(inputHour) || !isValidHour(inputHour)) {
			logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_PARSE_HOUR, inputHour, userInput)));
		} else {
			setField(FIELD_HOUR, Integer.parseInt(inputHour));
		}
	}
	
	// Parses dates in dd/mm, dd/mm/yy, dd/mm/yyy, dd/mm/yyyy format. E.g 12/5/16, 12/05/2016, 12/05.
	private boolean parseIfIsForwardSlashDateFormat(String input) throws Exception {
		if (input.contains(STRING_FORWARD_SLASH)) {
			String[] splitDate = input.split(STRING_FORWARD_SLASH);
			if (splitDate.length == DAY_MONTH_FORMAT_LENGTH) {
				return parseDayAndMonth(input);
			} else if (splitDate.length == DAY_MONTH_YEAR_FORMAT_LENGTH) {
				return parseDayMonthAndYear(input);
			} else {
				throw new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_FORWARD_SLASH_FORMAT, input));
			}
		}
		return false;
	}
	
	// E.g 12/5, 31/10
	private boolean parseDayAndMonth(String input) throws NumberFormatException, Exception {
		String[] splitDate = input.split(STRING_FORWARD_SLASH);
		String inputDay = splitDate[INDEX_DAY];
		String inputMonth = splitDate[INDEX_MONTH];
		parseDay(inputDay, input);
		parseMonth(inputMonth, input);
		return true;
	}
	
	// E.g 12/5/16, 31/10/2017
	private boolean parseDayMonthAndYear(String input) throws Exception {
		String[] splitDate = input.split(STRING_FORWARD_SLASH);
		String inputDay = splitDate[INDEX_DAY];
		String inputMonth = splitDate[INDEX_MONTH];
		String inputYear = splitDate[INDEX_YEAR];
		parseDay(inputDay, input);
		parseMonth(inputMonth, input);
		parseYear(inputYear, input);
		return true;
	}

	private void parseYear(String inputYear, String input) throws Exception {
		if (!isANumber(inputYear)) {
			logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_PARSE_YEAR, inputYear, input)));
		} else {
			int intYear = Integer.parseInt(inputYear);
			if (intYear < MIN_4_DIGIT_YEAR) {
				intYear += OFFSET_NOT_4_DIGIT_YEAR;
			}
			if (isAfterCurrentYear(intYear)) {
				setField(FIELD_YEAR, intYear);
			} else {
				logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_YEAR_PAST, inputYear, input)));
			}
		}
	}
	
	private boolean isAfterCurrentYear(int inputYear) {
		Calendar c = Calendar.getInstance();
		return inputYear >= c.get(Calendar.YEAR);
	}

	private void parseMonth(String inputMonth, String input) throws NumberFormatException, Exception {
		if (!isANumber(inputMonth) || !isValidMonth(inputMonth)) {
			logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_PARSE_MONTH, inputMonth, input)));
		} else {
			setField(FIELD_MONTH, Integer.parseInt(inputMonth));
		}
	}

	private void parseDay(String inputDay, String input) throws NumberFormatException, Exception {
		if (!isANumber(inputDay)) {
			logAndThrow(new InvalidDateTimeFieldException(String.format(ERROR_MESSAGE_PARSE_DAY, inputDay, input)));
		} else {
			setField(FIELD_DAY, Integer.parseInt(inputDay));
		}
	}
	
	// Parses numbers with 2 or less digits. E.g "12" may, "7" april.
	private boolean parseIfIs2OrLessDigitFloatingNumber(String input) throws NumberFormatException, Exception {
		if (isANumber(input) && input.length() <= 2) {
			setField(FIELD_DAY, Integer.parseInt(input));
			return true;
		}
		return false;
	}
	
	// Parses numbers with 4 digits. E.g (time) 1200, (time) 2359, (year) 2500. 
	private boolean parseIfIs4DigitFloatingNumber(String input) throws NumberFormatException, Exception{
		if (input.length() == FORMAT_LENGTH_4_DIGIT && isANumber(input)) {
			String inputHour = input.substring(START_INDEX, INDEX_SEPARATE_4_DIGIT_HOUR_MINUTE); // Gets first 2 digits.
			String inputMinute = input.substring(INDEX_SEPARATE_4_DIGIT_HOUR_MINUTE, FORMAT_LENGTH_4_DIGIT); // Gets last 2 digits.
			if (isValidHour(inputHour) && isValidMinute(inputMinute)) {
				setField(FIELD_HOUR, Integer.parseInt(inputHour));
				setField(FIELD_MINUTE, Integer.parseInt(inputMinute));
				return true;
			} else { // If hour or minute in 4 digit input is invalid, then treat input as year.
				setField(FIELD_YEAR, Integer.parseInt(input));
				return true;
			}
		}
		return false;
	}
	
	private boolean isValidMonth(String input) {
		int inputMonth = Integer.parseInt(input);
		return inputMonth >= MONTH_MIN && inputMonth <= MONTH_MAX;
	}
	
	private boolean isValidMinute(String input) {
		int inputInt = Integer.parseInt(input);
		return inputInt >= MINUTE_MIN && inputInt <= MINUTE_MAX;
	}
	
	private boolean isValidHour(String input) {
		int inputInt = Integer.parseInt(input);
		return inputInt >= HOUR_MIN && inputInt <= HOUR_MAX;
	}
	
	private boolean isANumber(String input) {
		if (input == EMPTY_STRING) {
			return false;
		}
		boolean isNumber = true;
		for (int i = 0; i < input.length(); i++) {
			if (!Character.isDigit(input.charAt(i))) {
				isNumber = false;
				break;
			}
		}
		return isNumber;
	}
	
	public void logAndThrow(Exception e) throws Exception {
        LOGGER.log(Level.WARNING, e.getMessage());
        throw e;
    }
}
```
###### \src\org\jimple\planner\test\parser\ParserTest.java
``` java

package org.jimple.planner.test.parser;
import static org.junit.Assert.*;

import org.jimple.planner.parser.InputStruct;
import org.jimple.planner.parser.Parser;
import org.junit.Test;

public class ParserTest {
	
	private static Parser testParser;
	
	@Test
	public void test() {
		testParser = new Parser();
		//test0();
		test1();
		test2();
		test3();
		test4();
		test5();
		test6();
		test7();
		test8();
		test9();
		test10();
		test11();
		test12();
		test13();
		test14();
		test15();
		test16();
		test17();
	}
	
	// Miscellaneous test - for my usage.
	private void test0() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("ADD Do CS2103T Pre-Tutorial activities BY 8 apr 2pm");
			String[] test = testStruct.getVariableArray();
			for (int i = 0; i < test.length; i++) {
				System.out.println(test[i]);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	/* Command: Add
	 * Input: Name, From (DMT), To (DMT), Label
	 * Expected: {event, Name, null, FromTime, ToTime, Label}
	 */
	private void test1() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("ADD Learn Double Dream Hands FROM 12 may 8am TO 13 may 12AM LABEL DOWNDOG");
			assertEquals(assertArray(testStruct, "event", "Learn Double Dream Hands", null, "2016-05-12T08:00", "2016-05-13T00:00", "DOWNDOG"), true);
		} catch (Exception e) {}
	}
	
	/* Command: ADD
	 * Input: Name (Symbols), From (DMT), To (DMT), Description
	 * Expected: {event, Name, Description, FromTime, ToTime, null}
	 */
	private void test2() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("ADD !@#$%^&*() FROM 12 jun 0123 TO 12 june 2030 DESCRIPTION UPDOG");
			assertEquals(assertArray(testStruct, "event", "!@#$%^&*()", "UPDOG", "2016-06-12T01:23", "2016-06-12T20:30", null), true);
		} catch (Exception e) {}
	}
	
	/* Command: ADD
	 * Input: nil
	 * Expected: Exception
	 */
	private void test3() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("ADD");
		} catch (Exception e) {
			assertEquals(e.getMessage(), "Command: \"ADD\" requires a Task Name.");
		}
	}
	
	/* Command: DELETE
	 * Input: Index
	 * Expected: {Index}
	 */
	private void test4() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("DELETE 2");
			assertEquals(assertArray(testStruct, "2"), true);
		} catch (Exception e) {}
	}
	
	/* Command: SEARCH
	 * Input: StringToSearch
	 * Expected: {StringToSearch}
	 */
	private void test5() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("SEARCH submit");
			assertEquals(assertArray(testStruct, "submit"), true);
		} catch (Exception e) {}
	}
	
	/* Command: ADD
	 * Input: Name ("ADD")
	 * Expected: {todo, "ADD", null, null, null, null}
	 */
	private void test6() {
		InputStruct testStruct;
		try {
			testStruct = testParser.parseInput("ADD ADD");
			assertEquals(assertArray(testStruct, "todo", "ADD", null, null, null, null), true);
		} catch (Exception e) {}
	}
	
	/* Command: ADD
	 * Input: Name, On (DM)
	 * Expected: {event, Name, null, OnDate (00:00), OnDate (23:59), null}
	 */
	private void test7() {
		InputStruct testStruct;
		try {
			testStruct = testParser.parseInput("ADD test7 ON 13 may");
			assertEquals(assertArray(testStruct, "event", "test7", null, "2016-05-13T00:00", "2016-05-13T23:59", null), true);
		} catch (Exception e) {}
	}
	
	/* Command: Invalid Command (asdf1234)
	 * Input: nil
	 * Expected: Exception
	 */
	private void test8() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("asdf1234");
		} catch (Exception e) {
			assertEquals(e.getMessage(), "Command: \"asdf1234\" not recognised.");
		}
	}
	
	/* Command: ADD
	 * Input: Name, At (DM)
	 * Expected: {event, Name, null, AtDate (00:00), AtDate (00:00 + 1hr), null}
	 */
	private void test9() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("ADD test9 AT 12 may");
			assertEquals(assertArray(testStruct, "event", "test9", null, "2016-05-12T00:00", "2016-05-12T01:00", null), true);
		} catch (Exception e) {}
	}
	
	/* Command: ADD
	 * Input: Name, At (D/M) T(hh:mm)
	 * Expected: {event, Name, null, AtDate&Time, AtDate&Time + 1hr, null}
	 */
	private void test10() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("ADD test10 AT 12/5 06:00");
			assertEquals(assertArray(testStruct, "event", "test10", null, "2016-05-12T06:00", "2016-05-12T07:00", null), true);
		} catch (Exception e) {}
	}
	
	/* Command: ADD
	 * Input: Name, By (D/M/Y)
	 * Expected: {event, Name, null, ByDateAndTime, null, null}
	 */
	private void test11() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("ADD test11 BY 12/5/17");
			assertEquals(assertArray(testStruct, "deadline", "test11", null, "2017-05-12T23:59", null, null), true);
		} catch (Exception e) {}
	}
	
	/* Command: EDITLABEL
	 * Input: Name, NameToChange, Colour
	 * Expected: {Name, NameToChange,Colour}
	 */
	private void test12() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("EDITLABEL asdf NAME qwerty COLOUR red");
			assertEquals(assertArray(testStruct, "asdf", "qwerty", "red"), true);
		} catch (Exception e) {}
	}
	
	/* Command: EDITLABEL
	 * Input: Name, Colour
	 * Expected: {Name, null, Colour}
	 */
	private void test13() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("EDITLABEL asdf NAME qwerty COLOUR orange");
			assertEquals(assertArray(testStruct, "asdf", "qwerty", "orange"), true);
		} catch (Exception e) {}
	}
	
	/* Command: EDITLABEL
	 * Input: Name, NameToChange, Colour (Invalid)
	 * Expected: Exception
	 */
	private void test14() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("EDITLABEL asdf NAME qwerty COLOUR notacolour");
		} catch (Exception e) {
			assertEquals(e.getMessage(), "Label Colour: \"notacolour\" invalid.");
			
		}
	}
	
	/* Command: DELETE LABEL
	 * Input: Name
	 * Expected: Name
	 */
	private void test15() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("DELETELABEL zxc");
			assertEquals(assertArray(testStruct, "zxc"), true);
		} catch (Exception e) {}
	}
	
	/* Command: CHECKCONFLICT
	 * Input: Index
	 * Expected: Index
	 */
	private void test16() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("CHECKCONFLICT 123");
			assertEquals(assertArray(testStruct, "123"), true);
		} catch (Exception e) {}
	}
	
	/* Command: DONE
	 * Input: Index
	 * Expected: Index
	 */
	private void test17() {
		InputStruct testStruct = null;
		try {
			testStruct = testParser.parseInput("DONE 123654789");
			assertEquals(assertArray(testStruct, "123654789"), true);
		} catch (Exception e) {}
	}
	
	private boolean assertArray(InputStruct inputStruct, String... args) {
		if (inputStruct == null && args[0] == "exception") {
			return true;
		}
		String[] variableArray = inputStruct.getVariableArray();
		if (variableArray.length != args.length) {
			return false;
		}
		for (int i = 0; i < variableArray.length; i++) {
			if (variableArray[i] == null && args[i] == null) {
				continue;
			} else if (!variableArray[i].equals(args[i])) {
				System.out.println(variableArray[i] + " " + args[i]);
				return false;
			}
		}
		return true;
	}

}
```
