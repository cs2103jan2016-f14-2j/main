# A0135808B
###### \src\org\jimple\planner\constants\Constants.java
``` java
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_TODO = "floating";
	public static final String TYPE_DEADLINE = "deadline";
```
###### \src\org\jimple\planner\constants\Constants.java
``` java
	public static final String EMPTY_STRING = "";
```
###### \src\org\jimple\planner\constants\Constants.java
``` java
	public static final String STRING_LABELNAME = "LABEL";
	public static final String STRING_LABELCOLOUR = "COLOUR";
	public static final int TASK_LABEL_COLOUR_DEFAULT_0 = 0;
	public static final int TASK_LABEL_COLOUR_BLUE_1 = 1;
	public static final int TASK_LABEL_COLOUR_GREEN_2 = 2;
	public static final int TASK_LABEL_COLOUR_YELLOW_3 = 3;
	public static final int TASK_LABEL_COLOUR_ORANGE_4 = 4;
	public static final int TASK_LABEL_COLOUR_RED_5 = 5;
	public static final int TASK_LABEL_COLOUR_PURPLE_6 = 6;
	public static final String TASK_LABEL_NAME_DEFAULT = "default";
	
	public static final String ERROR_INVALID_TASK = "Task is invalid";
	
	/*
	 * Storage Component
	 */
	
	public static final String DEFAULT_FILE_DIRECTORY = "jimpleFiles"+File.separator;
	public static final String DEFAULT_FILE_NAME = "planner.jim";
	public static final String DEFAULT_TEMP_FILE_NAME = "templanner.jim";
	public static final String TEST_FILE_NAME = "testplanner.jim";
	public static final String TEST_TEMP_FILE_NAME = "testtempplanner.jim";
	
	public static final String PROPERTIES_CONFIG_FILE_NAME = "jimpleConfig.properties";
	public static final String PROPERTIES_COMMENT_HEADER = "PATH SETTINGS";
	public static final String PROPERTIES_SAVEPATH_TO_CWD = "origin";
	
	public static final String PROPERTIES_KEY_CURRENT_SAVEPATH = "savepath";
	public static final String PROPERTIES_KEY_PREV_SAVEPATH = "prevsavepath";
	
	public static final String PROPERTIES_VALUE_COLOUR_BLUE_1 = "blue";
	public static final String PROPERTIES_VALUE_COLOUR_GREEN_2 = "green";
	public static final String PROPERTIES_VALUE_COLOUR_YELLOW_3 = "yellow";
	public static final String PROPERTIES_VALUE_COLOUR_ORANGE_4 = "orange";
	public static final String PROPERTIES_VALUE_COLOUR_RED_5 = "red";
	public static final String PROPERTIES_VALUE_COLOUR_PURPLE_6 = "purple";
	
	public static final String FILEPATH_DEFAULT = DEFAULT_FILE_DIRECTORY + DEFAULT_FILE_NAME;
	public static final String FILEPATH_DEFAULT_TEMP = DEFAULT_FILE_DIRECTORY + DEFAULT_TEMP_FILE_NAME;
	public static final String FILEPATH_TEST = DEFAULT_FILE_DIRECTORY + TEST_FILE_NAME;
	public static final String FILEPATH_TEST_TEMP = DEFAULT_FILE_DIRECTORY + TEST_TEMP_FILE_NAME;
	public static final String FILEPATH_CONFIG = DEFAULT_FILE_DIRECTORY+PROPERTIES_CONFIG_FILE_NAME;
	
	public static final String TAGS_LABEL = ":label:";
	public static final String TAGS_DESCRIPTION = ":desc:";
	public static final String TAGS_FROM_TIME = ":from:";
	public static final String TAGS_TO_TIME = ":to:";
	public static final String TAGS_TITLE = ":title:";
	public static final String TAGS_ISDONE = ":isDone:";
	public static final String TAGS_LINE_FIELD_SEPARATOR = "/s/";
	public static final String TAGS_LABEL_FIELD_SEPARATOR = "/tl/";
	
```
###### \src\org\jimple\planner\logfilehandler\LogFileHandler.java
``` java
public class LogFileHandler {

	public static void setFileHandler(){
		try {
			String fileName = getLogFileName();
			FileHandler handler = new FileHandler(fileName, true);
			handler.setFormatter(new SimpleFormatter());
			Logger.getLogger("").addHandler(handler);
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static String getLogFileName() {
		Calendar cal = Calendar.getInstance();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy");
		String dateStr = dateFormat.format(cal.getTime());
		String fileName = "jimpleLogs"+File.separator+"jimpleLog_"+dateStr+".log";
		return fileName;
	}

	public static void createDirectoryToLogFile(){
		String fileName = getLogFileName();
		File file = new File(fileName);
		assert !file.isDirectory();
		String dirPath = file.getAbsolutePath().replaceAll(file.getName(), EMPTY_STRING);
		File dir = new File(dirPath);
		dir.mkdirs();
	}
}
```
###### \src\org\jimple\planner\logic\LogicLinkLabelsToTasks.java
``` java
class LogicLinkLabelsToTasks {

	public static void linkTasksToLabels(ArrayList<ArrayList<Task>> allTasks, ArrayList<TaskLabel> labelList){
		for(ArrayList<Task> taskList: allTasks){
			for(Task task: taskList){
				TaskLabel currentTaskLabel = task.getTaskLabel();
				if(currentTaskLabel.equals(TaskLabel.createDefaultLabel())){
					break;
				}
				for(TaskLabel masterLabel: labelList){
					if(isSameLabel(currentTaskLabel, masterLabel)){
						currentTaskLabel = TaskLabel.createDuplicateTaskLabel(masterLabel);
						task.setTaskLabel(currentTaskLabel);
					}
				}
			}
		}
	}
	
	private static boolean isSameLabel(TaskLabel currentTaskLabel, TaskLabel masterLabel) {
		String currentTaskLabelName = currentTaskLabel.getLabelName();
		boolean labelNameEqual = masterLabel.getLabelName().equals(currentTaskLabelName);
		return labelNameEqual;
	}
}
```
###### \src\org\jimple\planner\logic\LogicSearch.java
``` java
	protected ArrayList<Task> searchWord(String wordToBeSearched, ArrayList<Task> todo, ArrayList<Task> deadlines,
			ArrayList<Task> events, ArrayList<Task> archivedTasks) {
		ArrayList<Task> searchWordResults = new ArrayList<Task>();
		searchWordResults.clear();
		mostRecentlySearchedWord = wordToBeSearched;

		if (todo.isEmpty() && deadlines.isEmpty() && events.isEmpty()) {
		} else {
			searchWordResults.addAll(getSearchedTasks(wordToBeSearched, todo));
			searchWordResults.addAll(getSearchedTasks(wordToBeSearched, deadlines));
			searchWordResults.addAll(getSearchedTasks(wordToBeSearched, events));
			searchWordResults.addAll(getSearchedTasks(wordToBeSearched, archivedTasks));
		}
		return searchWordResults;
	}

```
###### \src\org\jimple\planner\logic\LogicSearch.java
``` java
	private ArrayList<Task> getSearchedTasks(String wordToBeSearched, ArrayList<Task> list) {
		ArrayList<Task> objectOfTaskInstanceFound = new ArrayList<Task>();
		if (list != null) {
			for (int i = 0; i < list.size(); i++) {
				Task currentTask = list.get(i);
				if (isContainKeyword(currentTask, wordToBeSearched)) {
					objectOfTaskInstanceFound.add(list.get(i));
				}
			}
		}
		return objectOfTaskInstanceFound;
	}
	
```
###### \src\org\jimple\planner\logic\LogicSearch.java
``` java
	private boolean isContainKeyword(Task event, String keyword) {
		boolean isTitleSearched = isContainSearchedWord(event.getTitle(), keyword);
		boolean isDescSearched = isContainSearchedWord(event.getDescription(), keyword);
		boolean isLabelSearched = isContainSearchedWord(event.getTaskLabel().getLabelName(), keyword);
		return (isTitleSearched || isDescSearched || isLabelSearched);
	}

```
###### \src\org\jimple\planner\storage\Storage.java
``` java
public class Storage implements StorageInterface{
	private StorageSave storageSave;
	private StorageLoad storageLoad;
	private StorageProperties storageProperties;

	public Storage() {
		storageSave = new StorageSave();
		storageLoad = new StorageLoad();
		storageProperties = new StorageProperties();
	}

	@Override
	public boolean isSavedTasks(ArrayList<ArrayList<Task>> allTaskLists) {
		String fileName = storageProperties.getCurrentSaveFilePath();
		String tempFileName = storageProperties.getCurrentTempSaveFilePath();
		return storageSave.isSavedTasksSelect(allTaskLists, fileName, tempFileName);
	}

	@Override
	public boolean isSavedLabels(ArrayList<TaskLabel> labelList) {
		return storageProperties.isSavedLabels(labelList);
	}

	@Override	
	public ArrayList<ArrayList<Task>> getTasks(){
		String fileName = storageProperties.getCurrentSaveFilePath();
		return storageLoad.getTaskSelect(fileName);
	}

	@Override
	public ArrayList<TaskLabel> getLabels() {
		ArrayList<TaskLabel> labelList = null;
		labelList = storageProperties.getLabels();
		return labelList;
	}

	@Override
	public boolean setPath(String pathName) {
		return storageProperties.setPath(pathName);
	}

	@Override
	public String checkPath(){
		return storageProperties.checkPath();
	}
}
```
###### \src\org\jimple\planner\storage\StorageInterface.java
``` java
public interface StorageInterface{

	public boolean isSavedTasks(ArrayList<ArrayList<Task>> allTaskLists);

	public boolean isSavedLabels(ArrayList<TaskLabel> labelList);

	public ArrayList<ArrayList<Task>> getTasks();

	public ArrayList<TaskLabel> getLabels();

	public boolean setPath(String pathName);

	public String checkPath();
}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
public class StorageLoad implements StorageLoadInterface{
	private final static Logger LOGGER = Logger.getLogger(StorageLoad.class.getName());
	
	private BufferedReader createFileReader(String fileName){
		BufferedReader reader = null;
		try {
			File file = createFile(fileName);
			FileInputStream fileIn = new FileInputStream(file);
			InputStreamReader inputStreamReader = new InputStreamReader(fileIn, StandardCharsets.UTF_8);
			reader = new BufferedReader(inputStreamReader);
		} catch (FileNotFoundException e) {
			LOGGER.log(Level.SEVERE, e.toString(), e);
			e.printStackTrace();
		}
		return reader;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	public ArrayList<ArrayList<Task>> getTaskSelect(String filePath){
		BufferedReader defaultFileReader = createFileReader(filePath);
		return getTaskByReader(defaultFileReader);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private ArrayList<ArrayList<Task>> getTaskByReader(BufferedReader defaultFileReader) {
		ArrayList<ArrayList<Task>> allTasksLists = populateArrayList();
		String fileLineContent;
		try {
			while ((fileLineContent = defaultFileReader.readLine()) != null) {
				if(!fileLineContent.equals(EMPTY_STRING)){
					Task task = getTaskFromLine(fileLineContent);
					try {
						checkTaskValidity(task);
					} catch (InvalidTaskException e) {
						LOGGER.log(Level.SEVERE, e.toString(), e);
						LOGGER.severe(e.getMessage());
						LOGGER.severe("task title:" + task.getTitle());
						LOGGER.severe("task's fromTime is: "+task.getFromTime());
						LOGGER.severe("task's toTime is: "+task.getToTime());
						e.printStackTrace();
					}
					allocateTaskToArrayList(task, allTasksLists);
				}
			}
			defaultFileReader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		Task.sortTasks(allTasksLists);
		return allTasksLists;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private ArrayList<ArrayList<Task>> populateArrayList(){
		ArrayList<ArrayList<Task>> allTasksLists = new ArrayList<ArrayList<Task>>();
		allTasksLists.add(new ArrayList<Task>());
		allTasksLists.add(new ArrayList<Task>());
		allTasksLists.add(new ArrayList<Task>());
		allTasksLists.add(new ArrayList<Task>());
		return allTasksLists;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private ArrayList<String> getSeparateFields(String fileLineContent){
		Pattern pattern = Pattern.compile(TAGS_LINE_FIELD_SEPARATOR);
		String[] separatedContentsArray = pattern.split(fileLineContent);
		ArrayList<String> separatedContents = new ArrayList<String>(Arrays.asList(separatedContentsArray));
		return separatedContents;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private Task getTaskFromLine(String fileLineContent){
		ArrayList<String> fileLineContentSeparated = getSeparateFields(fileLineContent);
		Task task = new Task(EMPTY_STRING);
		for(String field: fileLineContentSeparated){
			setFields(task, field);
		}
		return task;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private void setFields(Task task, String field){
		if(isTitle(field)){
			String titleString = getRemovedTitleTagString(field);
			task.setTitle(titleString);
		} else if(isLabel(field)){
			ArrayList<String> labelStringArray = getRemovedLabelTagStringArray(field);
			TaskLabel taskLabel = TaskLabel.createDummyLabel(labelStringArray.get(0), Integer.parseInt(labelStringArray.get(1)));
			task.setTaskLabel(taskLabel);
		} else if(isDescription(field)){
			String descField = getRemovedDescriptionTagString(field);
			task.setDescription(descField);
		} else if(isFromTime(field)){
			String fromField = getRemovedFromTagString(field);
			task.setFromDate(fromField);
		} else if (isToTime(field)){
			String toField = getRemovedToTagString(field);
			task.setToDate(toField);
		} else if (isIsDone(field)){
			String isDoneString = getRemovedIsDoneTagString(field);
			boolean isDoneField = Boolean.parseBoolean(isDoneString);
			task.setIsDone(isDoneField);
		}
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private boolean isTitle(String field){
		return field.contains(TAGS_TITLE);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private boolean isLabel(String field){
		return field.contains(TAGS_LABEL);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private boolean isDescription(String field){
		return field.contains(TAGS_DESCRIPTION);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private boolean isFromTime(String field){
		return field.contains(TAGS_FROM_TIME);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private boolean isToTime(String field){
		return field.contains(TAGS_TO_TIME);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private boolean isIsDone(String field){
		return field.contains(TAGS_ISDONE);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private String getRemovedIsDoneTagString(String field){
		String removedTag = field.replace(TAGS_ISDONE, EMPTY_STRING);
		return removedTag;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private String getRemovedTitleTagString(String field){
		String removedTag = field.replace(TAGS_TITLE, EMPTY_STRING);
		return removedTag;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private ArrayList<String> getRemovedLabelTagStringArray(String field){
		String removedTag = field.replace(TAGS_LABEL, EMPTY_STRING);
		Pattern pattern = Pattern.compile(TAGS_LABEL_FIELD_SEPARATOR);
		String[] splitLabelFields = pattern.split(removedTag);
		ArrayList<String> splitLabelFieldsWithNoEmptyString = new ArrayList<String>();
		for(String string: splitLabelFields){
			if(string.equals(EMPTY_STRING) || string==null){
				continue;
			}
			splitLabelFieldsWithNoEmptyString.add(string);
		}
		return splitLabelFieldsWithNoEmptyString;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private String getRemovedDescriptionTagString(String field){
		String removedTag = field.replace(TAGS_DESCRIPTION, EMPTY_STRING);
		return removedTag;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private String getRemovedFromTagString(String field){
		String removedTag = field.replace(TAGS_FROM_TIME, EMPTY_STRING);
		return removedTag;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private String getRemovedToTagString(String field){
		String removedTag = field.replace(TAGS_TO_TIME, EMPTY_STRING);
		return removedTag;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private void allocateTaskToArrayList(Task task, ArrayList<ArrayList<Task>> allTasksLists){
		assert allTasksLists.size() == 4;
		if(task.getIsDone()){
			allTasksLists.get(3).add(task);
		} else{
			String taskType = task.getType();
			switch(taskType){
			case TYPE_TODO:
				allTasksLists.get(0).add(task);
				break;
			case TYPE_DEADLINE:
				allTasksLists.get(1).add(task);
				break;
			case TYPE_EVENT:
				allTasksLists.get(2).add(task);
				break;
			}
		}
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	public Properties loadProperties(){
		String configPath = FILEPATH_CONFIG;
		BufferedReader configFileReader = createFileReader(configPath);
		Properties property = new Properties();
		try {
			property.load(configFileReader);
				if(property.isEmpty()){
					propertyKeysInitialise(property);
				}
				configFileReader.close();
		} catch (IOException e) {
			LOGGER.log(Level.SEVERE, e.toString(), e);
			e.printStackTrace();
		}
		return property;
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	private void propertyKeysInitialise(Properties property){
		setKeys(property, PROPERTIES_KEY_CURRENT_SAVEPATH, PROPERTIES_SAVEPATH_TO_CWD);
		setKeys(property, PROPERTIES_KEY_PREV_SAVEPATH, PROPERTIES_SAVEPATH_TO_CWD);
	}
	
	private void setKeys(Properties property, String key, String value){
		if(property.getProperty(key) == null){
			property.setProperty(key, value);
		}
	}
	/*
	 * ALL TEST METHODS HERE
	 */
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	public ArrayList<ArrayList<Task>> getTestTasks(){
		return getTaskSelect(FILEPATH_TEST);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	public Task testGetTaskFromLine(String fileLineContent){
		return getTaskFromLine(fileLineContent);
	}
```
###### \src\org\jimple\planner\storage\StorageLoad.java
``` java
	public String[] testExtractTasksToStringArray(Task task){
		String[] result = new String[6];
		result[0] = task.getTitle();
		result[1] = task.getDescription();
		TaskLabel taskLabel = task.getTaskLabel();
		result[2] = taskLabel.getLabelName() + " " + String.valueOf(taskLabel.getColourId());
		result[3] = task.getFromTimeString();
		result[4] = task.getToTimeString();
		result[5] = task.getType();
		return result;
	}
}
```
###### \src\org\jimple\planner\storage\StorageLoadInterface.java
``` java
public interface StorageLoadInterface extends StorageToolsInterface{

	public ArrayList<ArrayList<Task>> getTaskSelect(String filePath);
}
```
###### \src\org\jimple\planner\storage\StorageProperties.java
``` java
public class StorageProperties implements StorageToolsInterface{
	private StorageSave storageSave;
	private StorageLoad storageLoad;
	private final static Logger LOGGER = Logger.getLogger(StorageProperties.class.getName());
	private static HashMap<String, Integer> colourToId = new HashMap<String, Integer>();

	public StorageProperties(){
		storageSave = new StorageSave();
		storageLoad = new StorageLoad();
		initialiseHashMap();
	}

	private void initialiseHashMap(){
		colourToId.put(PROPERTIES_VALUE_COLOUR_BLUE_1, TASK_LABEL_COLOUR_BLUE_1);
		colourToId.put(PROPERTIES_VALUE_COLOUR_GREEN_2, TASK_LABEL_COLOUR_GREEN_2);
		colourToId.put(PROPERTIES_VALUE_COLOUR_YELLOW_3, TASK_LABEL_COLOUR_YELLOW_3);
		colourToId.put(PROPERTIES_VALUE_COLOUR_ORANGE_4, TASK_LABEL_COLOUR_ORANGE_4);
		colourToId.put(PROPERTIES_VALUE_COLOUR_RED_5, TASK_LABEL_COLOUR_RED_5);
		colourToId.put(PROPERTIES_VALUE_COLOUR_PURPLE_6, TASK_LABEL_COLOUR_PURPLE_6);
	}

	public boolean setPath(String pathName){
		Properties storageProperties = storageLoad.loadProperties();
		boolean setStatus = false;
		if(isFilePathValid(pathName)){
			if(isKeyChanged(pathName, storageProperties)){
				setStatus = copyToNewLocation(storageProperties);
				deleteResidualDirectory(storageProperties);
			}
		}
		storageSave.saveProperties(storageProperties);
		return setStatus;
	}

	private boolean isFilePathValid(String filePath){
		if(filePath.equals(PROPERTIES_SAVEPATH_TO_CWD)){
			return true;
		} else if(filePath.equals(EMPTY_STRING)){
			return false;
		}
        try {
            Paths.get(filePath);
            File fileDir = new File(filePath);
            return fileDir.isDirectory();
        } catch (InvalidPathException | NullPointerException ex) {
            return false;
        }
    }

	private boolean isKeyChanged(String pathName, Properties storageProperties){
		String previousPath = storageProperties.getProperty(PROPERTIES_KEY_CURRENT_SAVEPATH);
		if(previousPath.equals(pathName)){
			return false;
		} else if (isValueSame(pathName, previousPath)){ //This is mostly only to check if both prev and current are origin
			setIfOrigin(pathName, previousPath);
			return false;
		} else{
			storageProperties.setProperty(PROPERTIES_KEY_PREV_SAVEPATH, previousPath);
			storageProperties.setProperty(PROPERTIES_KEY_CURRENT_SAVEPATH, pathName);
			return true;
		}
	}

	private void setIfOrigin(String pathName, String previousPath) {
		Properties storageProperties = storageLoad.loadProperties();
		if(pathName.equals(PROPERTIES_SAVEPATH_TO_CWD)){
			storageProperties.setProperty(PROPERTIES_KEY_CURRENT_SAVEPATH, pathName);
			storageProperties.setProperty(PROPERTIES_KEY_PREV_SAVEPATH, pathName);
		} else if(previousPath.equals(PROPERTIES_SAVEPATH_TO_CWD)){
			storageProperties.setProperty(PROPERTIES_KEY_CURRENT_SAVEPATH, previousPath);
			storageProperties.setProperty(PROPERTIES_KEY_PREV_SAVEPATH, previousPath);
		}
	}

	private boolean isValueSame(String pathName, String previousPath) {
		String previousFileDir = (new File(getFileDirectory(previousPath))).getAbsolutePath();
		String currentFileDir = (new File(getFileDirectory(pathName))).getAbsolutePath();
		return (previousFileDir.equals(currentFileDir));
	}

	private boolean copyToNewLocation(Properties storageProperties){
		String newDir = getCurrentFileDirectory(storageProperties);
		String oldDir = getOldFileDirectory(storageProperties);
		
		String newPath = getFilePath(newDir);
		String oldPath = getFilePath(oldDir);
		
		ArrayList<ArrayList<Task>> consolidatedTasks = getConsolidatedTasks(newPath, oldPath);
		boolean saveStatus = storageSave.isSavedTasksSelect(consolidatedTasks, newPath, oldPath);
		return saveStatus;
	}

	private ArrayList<ArrayList<Task>> getConsolidatedTasks(String newPath, String oldPath){
		ArrayList<ArrayList<Task>> oldPathTasks = storageLoad.getTaskSelect(oldPath);
		ArrayList<ArrayList<Task>> newPathTasks = storageLoad.getTaskSelect(newPath);
		ArrayList<ArrayList<Task>> consolidatedTasks = removeDuplicateTasks(oldPathTasks, newPathTasks);
		Task.sortTasks(consolidatedTasks);
		return consolidatedTasks;
	}

	private ArrayList<ArrayList<Task>> removeDuplicateTasks(ArrayList<ArrayList<Task>> oldPathTasks,
			ArrayList<ArrayList<Task>> newPathTasks) {
		ArrayList<ArrayList<Task>> consolidatedTasks = new ArrayList<ArrayList<Task>>();
		for(int i = 0; i < 4; i++){
			ArrayList<Task> newTasksByType = newPathTasks.get(i);
			ArrayList<Task> oldTasksByType = oldPathTasks.get(i);
			oldTasksByType.addAll(newTasksByType);
			assignTaskIds(oldPathTasks);
			HashSet<Task> removeDuplicatedTasksByType = new HashSet<Task>(oldTasksByType);
			ArrayList<Task> consolidatedTasksByType = new ArrayList<Task>(removeDuplicatedTasksByType);
			consolidatedTasks.add(consolidatedTasksByType);
		}
		return consolidatedTasks;
	}

	private void deleteResidualDirectory(Properties storageProperties){
		String oldFileDirPath = storageProperties.getProperty(PROPERTIES_KEY_PREV_SAVEPATH);
		oldFileDirPath = getFullFilePath(oldFileDirPath, DEFAULT_FILE_DIRECTORY);
		if(!oldFileDirPath.equals(PROPERTIES_SAVEPATH_TO_CWD)){
			File oldFileDir = new File(oldFileDirPath);
			if(oldFileDir.isDirectory()){
				oldFileDir.delete();
			}
		}
	}

	private String getFileDirectoryFromProperties(Properties storageProperties, String key){
		String fileDir = storageProperties.getProperty(key);
		fileDir = getFileDirectory(fileDir);
		return fileDir;
	}

	private String getFileDirectory(String fileDir) {
		if(fileDir.equals(PROPERTIES_SAVEPATH_TO_CWD)){
			fileDir = EMPTY_STRING;
		}
		return fileDir;
	}

	private String getCurrentFileDirectory(Properties storageProperties){
		return getFileDirectoryFromProperties(storageProperties, PROPERTIES_KEY_CURRENT_SAVEPATH);
	}

	private String getOldFileDirectory(Properties storageProperties){
		return getFileDirectoryFromProperties(storageProperties, PROPERTIES_KEY_PREV_SAVEPATH);
	}

	private String getFullFilePath(String fileSaveDir, String fileName) {
		String fileString = EMPTY_STRING;
		if(fileSaveDir.equals(EMPTY_STRING) || fileSaveDir.endsWith(File.separator)){
			fileString = fileSaveDir + fileName;
		} else {
			fileString = fileSaveDir + File.separator + fileName;
		}
		return fileString;
	}

	private String getFilePath(String fileSaveDir){
		return getFullFilePath(fileSaveDir, FILEPATH_DEFAULT);
	}

	private String getTempFilePath(String fileSaveDir){
		return getFullFilePath(fileSaveDir, FILEPATH_DEFAULT_TEMP);
	}

	private String getCurrentFilePath(Properties storageProperties){
		String currentFileDir = getCurrentFileDirectory(storageProperties);
		return getFilePath(currentFileDir);
	}

	private String getCurrentTempFilePath(Properties storageProperties){
		String currentFileDir = getCurrentFileDirectory(storageProperties);
		return getTempFilePath(currentFileDir);
	}

	public String getCurrentSaveFilePath(){
		Properties storageProperties = storageLoad.loadProperties();
		return getCurrentFilePath(storageProperties);
	}

	public String getCurrentTempSaveFilePath(){
		Properties storageProperties = storageLoad.loadProperties();
		return getCurrentTempFilePath(storageProperties);
	}

	public String checkPath(){
		Properties storageProperties = storageLoad.loadProperties();
		String currentPath = getCurrentFileDirectory(storageProperties);
		if(currentPath.equals(EMPTY_STRING)){
			File currentPathFile = new File(currentPath);
			currentPath = currentPathFile.getAbsolutePath();
		} 
		return currentPath;
	}

	public boolean isSavedLabels(ArrayList<TaskLabel> labelLists){
		Properties newStorageProperties = getPathProperties();
		for(TaskLabel taskLabel: labelLists){
			if(taskLabel.equals(TaskLabel.createDefaultLabel())){
				continue;
			}
			String labelName = taskLabel.getLabelName();
			int labelColourId = taskLabel.getColourId();
			String labelColourString = null;
			switch(labelColourId){
			case TASK_LABEL_COLOUR_BLUE_1:
				labelColourString = PROPERTIES_VALUE_COLOUR_BLUE_1;
				break;
				
			case TASK_LABEL_COLOUR_GREEN_2:
				labelColourString = PROPERTIES_VALUE_COLOUR_GREEN_2;
				break;
				
			case TASK_LABEL_COLOUR_YELLOW_3:
				labelColourString = PROPERTIES_VALUE_COLOUR_YELLOW_3;
				break;
			
			case TASK_LABEL_COLOUR_ORANGE_4:
				labelColourString = PROPERTIES_VALUE_COLOUR_ORANGE_4;
				break;
			
			case TASK_LABEL_COLOUR_RED_5:
				labelColourString = PROPERTIES_VALUE_COLOUR_RED_5;
				break;
			
			case TASK_LABEL_COLOUR_PURPLE_6:
				labelColourString = PROPERTIES_VALUE_COLOUR_PURPLE_6;
				break;
			default:
				LOGGER.warning("Error, no label should have its colour id be invalid");
				LOGGER.warning("label name: "+taskLabel.getLabelName());
				LOGGER.warning("label colourId: "+taskLabel.getColourId());
				return false;
			}
			newStorageProperties.setProperty(labelName, labelColourString);
		}
		storageSave.saveProperties(newStorageProperties);
		return true;
	}

	private Properties getPathProperties() {
		Properties storageProperties = storageLoad.loadProperties();
		Properties newStorageProperties = new Properties();
		String currentPath = storageProperties.getProperty(PROPERTIES_KEY_CURRENT_SAVEPATH);
		String prevPath = storageProperties.getProperty(PROPERTIES_KEY_PREV_SAVEPATH);
		newStorageProperties.setProperty(PROPERTIES_KEY_CURRENT_SAVEPATH, currentPath);
		newStorageProperties.setProperty(PROPERTIES_KEY_PREV_SAVEPATH, prevPath);
		return newStorageProperties;
	}

	public ArrayList<TaskLabel> getLabels(){
		Properties storageProperties = storageLoad.loadProperties();
		ArrayList<TaskLabel> labelList = new ArrayList<TaskLabel>();
		labelList.add(TaskLabel.createDefaultLabel()); //1st element of labelList is always default label
		
		Set<Object> propertiesKeys = storageProperties.keySet();
		boolean removed_savepath_key = propertiesKeys.remove((Object)PROPERTIES_KEY_CURRENT_SAVEPATH);
		boolean removed_prev_savepath_key = propertiesKeys.remove((Object)PROPERTIES_KEY_PREV_SAVEPATH);
		assert removed_prev_savepath_key;
		assert removed_savepath_key;
		for(Object labelNames: propertiesKeys){
			String labelNamesString = (String) labelNames;
			String labelColourString = storageProperties.getProperty(labelNamesString);
			int labelColourId = colourToId.get(labelColourString);
			TaskLabel taskLabel = TaskLabel.createNewLabel(labelNamesString, labelColourId);
			labelList.add(taskLabel);
		}
		return labelList;
	}
	
	/*
	 * ALL TEST METHODS ARE HERE
	 */
	public boolean testIsFilePathValid(String filePath){
		return isFilePathValid(filePath);
	}
}
```
###### \src\org\jimple\planner\storage\StorageSave.java
``` java
public class StorageSave implements StorageSaveInterface{
	private final static Logger LOGGER = Logger.getLogger(StorageSave.class.getName());

	private BufferedWriter createFileWriter(String fileName){
		BufferedWriter writer = null;
		try {
			File file = createFile(fileName);
			FileOutputStream fileOut = new FileOutputStream(file);
			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOut, StandardCharsets.UTF_8);
			writer = new BufferedWriter(outputStreamWriter);
		} catch (FileNotFoundException e) {
			LOGGER.log(Level.SEVERE, e.toString(), e);
			e.printStackTrace();
		}
		return writer;
	}

	public boolean isSavedTasksSelect(ArrayList<ArrayList<Task>> allTaskLists, String filePath, String tempFilePath){
		assert allTaskLists.size() == 4;
		Task.sortTasks(allTaskLists);
		writeTasksToFile(allTaskLists, tempFilePath);
		boolean saveStatus = isSaveToFile(filePath, tempFilePath);
		return saveStatus;
	}

	private void writeTasksToFile(ArrayList<ArrayList<Task>> allTaskLists, String tempFilePath){
		BufferedWriter tempWriter = createFileWriter(tempFilePath);
		writeTasksUsingWriter(allTaskLists, tempWriter);
	}

	private void writeTasksUsingWriter(ArrayList<ArrayList<Task>> allTaskLists, BufferedWriter tempWriter) {
		try {
			for(ArrayList<Task> taskList: allTaskLists){
				writeArrayOfTasksUsingWriters(taskList, tempWriter);
			}
			tempWriter.close();
		} catch (IOException e) {
			LOGGER.log(Level.SEVERE, e.toString(), e);
			e.printStackTrace();
		} catch (NullPointerException e){
			LOGGER.log(Level.SEVERE, e.toString(), e);
			e.printStackTrace();
		}
	}

	private void writeArrayOfTasksUsingWriters(ArrayList<Task> taskList, BufferedWriter tempWriter){
			for(Task task: taskList){
				try {
					checkTaskValidity(task);
				} catch (InvalidTaskException e) {
					LOGGER.log(Level.SEVERE, e.toString(), e);
					LOGGER.severe(e.getMessage());
					LOGGER.severe("task title:" + task.getTitle());
					LOGGER.severe("task's fromTime is: "+task.getFromTime());
					LOGGER.severe("task's toTime is: "+task.getToTime());
					e.printStackTrace();
				}
				String lineString = extractTaskToString(task);
				try {
					tempWriter.write(lineString);
					tempWriter.newLine();
				} catch (IOException e) {
					LOGGER.log(Level.SEVERE, e.toString(), e);
					e.printStackTrace();
				}
		}
	}

	private boolean isSaveToFile(String filePath, String tempFilePath){
		File file = createFile(filePath);
		File tempFile = createFile(tempFilePath);
		if(!file.delete() || !tempFile.renameTo(file)){
			return false;
		} else {
			return true;
		}
	}

	private String extractTaskToString(Task task){
		System.out.println(task.getIsDone());
		String lineString = formatToSaveString(TAGS_ISDONE + Boolean.toString(task.getIsDone()));
		String titleString = formatToSaveString(TAGS_TITLE + task.getTitle());
		lineString = lineString + titleString;
		if(isDescriptionExist(task)){
			String descriptionString = formatToSaveString(TAGS_DESCRIPTION + task.getDescription());
			lineString = lineString + descriptionString;
		} 
		if (isFromTimeExist(task)){
			String fromTimeString = formatToSaveString(TAGS_FROM_TIME + task.getFromTime());
			lineString = lineString + fromTimeString;
		} 
		if (isToTimeExist(task)){
			String fromToString = formatToSaveString(TAGS_TO_TIME + task.getToTime());
			lineString = lineString + fromToString;
		}
		TaskLabel taskLabel = task.getTaskLabel();
		if(!taskLabel.equals(TaskLabel.createDefaultLabel())){
			String taskLabelToString = formatToTaskLabel(taskLabel);
			lineString = lineString + taskLabelToString;
		}
		return lineString;
	}

	private boolean isDescriptionExist(Task task){
		return !(task.getDescription().length()==0);
	}

	private boolean isFromTimeExist(Task task){
		return !(task.getFromTimeString().length()==0);
	}

	private boolean isToTimeExist(Task task){
		return !(task.getToTimeString().length()==0);
	}
	
	//Minor formatting of string such that each "field" is enclosed with a "/s/"
	private String formatToSaveString(String string){
		return TAGS_LINE_FIELD_SEPARATOR + string + TAGS_LINE_FIELD_SEPARATOR;
	}

	private String formatToTaskLabel(TaskLabel taskLabel){
		String labelName = formatLabelFields(taskLabel.getLabelName());
		String labelColourIdString = formatLabelFields(String.valueOf(taskLabel.getColourId()));
		String formattedString = TAGS_LABEL + labelName + labelColourIdString;
		return formattedString;
	}

	private String formatLabelFields(String string){
		return TAGS_LABEL_FIELD_SEPARATOR + string + TAGS_LABEL_FIELD_SEPARATOR;
	}

	public void saveProperties(Properties property){
		BufferedWriter configFileWriter = createFileWriter(FILEPATH_CONFIG);
		try {
			property.store(configFileWriter, PROPERTIES_COMMENT_HEADER);
			configFileWriter.close();
		} catch (IOException e) {
			LOGGER.log(Level.SEVERE, e.toString(), e);
			e.printStackTrace();
		}
	}
	
	/*
	 * ALL TEST METHODS ARE HERE
	 */
	public boolean isSavedTasksTest(ArrayList<ArrayList<Task>> allTaskLists){
		return isSavedTasksSelect(allTaskLists, FILEPATH_TEST, FILEPATH_TEST_TEMP);
	}

	public void testWriteTasks(ArrayList<ArrayList<Task>> allTaskLists, BufferedWriter tempWriter) {
		Task.sortTasks(allTaskLists);
		writeTasksUsingWriter(allTaskLists, tempWriter);
	}
}
```
###### \src\org\jimple\planner\storage\StorageSaveInterface.java
``` java
public interface StorageSaveInterface extends StorageToolsInterface{

	public boolean isSavedTasksSelect(ArrayList<ArrayList<Task>> allTasksList, String filePath, String tempFilePath);
}
```
###### \src\org\jimple\planner\storage\StorageToolsInterface.java
``` java
public interface StorageToolsInterface {

	default File createFile(String fileName) {
		File file = new File(fileName);
		
		assert !file.isDirectory();
		
		String dirPath = file.getAbsolutePath().replaceAll(file.getName(), EMPTY_STRING);
		File dir = new File(dirPath);
		dir.mkdirs();
		try {
			file.createNewFile();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return file;
	}

	default void assignTaskIds(ArrayList<ArrayList<Task>> allTasksArray) {
		int taskId = 1;
		for (ArrayList<Task> taskList : allTasksArray) {
			for (Task task : taskList) {
				task.setTaskId(taskId);
				taskId++;
			}
		}
	}

	default void checkTaskValidity(Task task) throws InvalidTaskException {
		if(!task.isValidType()){
			InvalidTaskException invalidTaskException = new InvalidTaskException(ERROR_INVALID_TASK);
				throw invalidTaskException;
		}
	}
}
```
###### \src\org\jimple\planner\task\Task.java
``` java
public class Task {
	private LocalDateTime fromDateTime;
	private LocalDateTime toDateTime;
	private String title;
	private String description;
	private String type;
	private boolean isOverDue;
	private boolean isDone;
	private int taskId;
	private ArrayList<Task> conflictedTasks;
	private TaskLabel taskLabel;
	private static Formatter formatter = new Formatter();
	private static TaskSorter taskSorter = new TaskSorter();
	

	// Default Constructor
	public Task(String aTitle) {
		this.title = aTitle;
		this.description = new String("");
		this.fromDateTime = null;
		this.toDateTime = null;
		this.type = TYPE_TODO;
		this.isOverDue = false;
		this.isDone = false;
		this.taskId = 1000;
		this.taskLabel = TaskLabel.createDefaultLabel();
		this.conflictedTasks = new ArrayList<Task>();
	}

	// Constructor for creating a duplicate
	public Task(Task taskToBeDuplicated) {
		this.title = taskToBeDuplicated.getTitle();
		this.description = taskToBeDuplicated.getDescription();
		this.fromDateTime = taskToBeDuplicated.getFromTime();
		this.toDateTime = taskToBeDuplicated.getToTime();
		this.type = taskToBeDuplicated.getType();
		this.isOverDue = taskToBeDuplicated.getIsOverDue();
		this.isDone = taskToBeDuplicated.getIsDone();
		this.taskId = taskToBeDuplicated.getTaskId();
		this.taskLabel = taskToBeDuplicated.getTaskLabel();
		this.conflictedTasks = taskToBeDuplicated.getConflictedTasks();
	}
	

	public String getPrettierFromDate(){
		String prettierFromDate = new String("");
		if(fromDateTime.getDayOfYear() == LocalDateTime.now().getDayOfYear()){
			prettierFromDate += "TODAY, ";
		}
		else{
			prettierFromDate += fromDateTime.getDayOfWeek() + ", ";
		}
		prettierFromDate += fromDateTime.getDayOfMonth() + " " + fromDateTime.getMonth() + " " + fromDateTime.getYear();
		return prettierFromDate;
	}
	

	public String getPrettyFromDate() {
		String prettyFromDate = new String("");
		prettyFromDate = formatter.formatPrettyDate(fromDateTime);
		return prettyFromDate;
	}
	

	public String getPrettyToDate() {
		String prettyToDate = new String("");
		prettyToDate = formatter.formatPrettyDate(toDateTime);
		return prettyToDate;
	}
	

	public String getPrettyFromTime() {
		String prettyFromTime = new String("");
		prettyFromTime = formatter.formatPrettyTime(fromDateTime);
		return prettyFromTime;
	}
	
	public String getPrettyToTime() {
		String prettyToTime = new String("");
		prettyToTime = formatter.formatPrettyTime(toDateTime);
		return prettyToTime;
	}
	
	public String getFromTimeString() {
		if (fromDateTime == null) {
			return "";
		}
		return fromDateTime.toString();
	}
	
	public LocalDateTime getFromTime() {
		return fromDateTime;
	}

	public void setFromDate(String dateTime) {
		if (dateTime != null) {
			this.fromDateTime = LocalDateTime.parse(dateTime);
		}
		checkAndSetType();
	}

	public String getToTimeString() {
		if (toDateTime == null) {
			return "";
		}
		return toDateTime.toString();
	}

	public LocalDateTime getToTime() {
		return toDateTime;
	}

	public void setToDate(String dateTime) {
		if (dateTime != null) {
			this.toDateTime = LocalDateTime.parse(dateTime);
		} else	{
			this.toDateTime = null;
		}
		checkAndSetType();
	}

	public String getType() {
		return type;
	}

	// THIS METHOD IS USED ONLY FOR TEST PURPOSES
	public void setType(String type) {
		this.type = type;
	}

	private void checkAndSetType() {
		if (isTodo()) {
			this.type = TYPE_TODO;
		} else if (isDeadline()) {
			this.type = TYPE_DEADLINE;
		} else if (isEvent()) {
			this.type = TYPE_EVENT;
		}
	}

	private boolean isTodo() {
		return (getToTime() == null && getFromTime() == null);
	}

	private boolean isDeadline() {
		return (getFromTime() != null && getToTime() == null);
	}

	private boolean isEvent() {
		return (getFromTime() != null && getToTime() != null);
	}

	public boolean isValidType() {
		if (isTodo()) {
			return true;
		} else if (isDeadline()) {
			return true;
		} else if (isEvent()) {
			return true;
		} else {
			return false;
		}
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getDescription() {
		if (description == null) {
			return "";
		}
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public TaskLabel getTaskLabel() {
		return taskLabel;
	}

	public void setIsOverDue(boolean overDueStatus) {
		isOverDue = overDueStatus;
	}

	public boolean getIsOverDue() {
		return isOverDue;
	}

	/**
	 * labels: 0 - default 1 - blue 2 - green 3 - yellow 4 - orange 5 - red 6 -
	 * dark red
	 */

	public void setTaskLabel(TaskLabel label) {
		this.taskLabel = label;
	}

	public void setTaskId(int taskId) {
		this.taskId = taskId;
	}

	public int getTaskId() {
		return taskId;
	}

	public boolean getIsDone(){
		return isDone;
	}

	public void setIsDone(boolean isDone){
		this.isDone = isDone;
	}
```
###### \src\org\jimple\planner\task\Task.java
``` java
	public static void sortTasks(ArrayList<ArrayList<Task>> allTaskLists) {
		taskSorter.sortTasks(allTaskLists);
	}

	public static void sortTasksByTime(ArrayList<Task> list) {
		taskSorter.sortTasksByTime(list);
	}
```
###### \src\org\jimple\planner\task\TaskLabel.java
``` java
public class TaskLabel {
	private String labelName;
	private int colourId;
	private int labelId;

	private TaskLabel(String name, int colourId, int labelId){
		this.labelName = name;
		this.colourId = colourId;
		this.labelId = labelId;
	}

	public static TaskLabel createDefaultLabel(){
		return new TaskLabel(TASK_LABEL_NAME_DEFAULT, TASK_LABEL_COLOUR_DEFAULT_0, 0);
	}

	public static TaskLabel createNewLabel(String name){
		int colourId = getNextLabelColourId();
		TaskLabel newLabel = createNewLabel(name, colourId);
		return newLabel;
	}

	public static TaskLabel createNewLabel(String name, int colourId){
		int id = getNextLabelId();
		TaskLabel newLabel = new TaskLabel(name, colourId, id);
		return newLabel;
	}

	public static TaskLabel createDuplicateTaskLabel(TaskLabel taskLabel){
		String aName = taskLabel.getLabelName();
		int aColourId = taskLabel.getColourId();
		int alabelId = taskLabel.getLabelId();
		TaskLabel duplicatedTaskLabel = new TaskLabel(aName, aColourId, alabelId);
		return duplicatedTaskLabel;
	}

	public static TaskLabel createDummyLabel(String name, int colourId){
		return new TaskLabel(name, colourId, 0);
	}

	private static int getNextLabelId() {
		int id = generateRandomIntegers(Integer.MAX_VALUE);
		return id;
	}

	private static int getNextLabelColourId(){
		int colourId = generateRandomIntegers(7);
		return colourId;
	}
	
	//generates a number from [1, bound), bound exclusive

	private static int generateRandomIntegers(int bound){
		SecureRandom randomGen = new SecureRandom();
		int id = randomGen.nextInt(bound);
		while(id==0){
			id = randomGen.nextInt(bound);
		}
		return id;
	}

	public String getLabelName() {
		return labelName;
	}

	public void setLabelName(String labelName) {
		this.labelName = labelName;
	}

	public int getColourId() {
		return colourId;
	}

	public void setColourId(int labelColourId) {
		this.colourId = labelColourId;
	}

	public int getLabelId() {
		return labelId;
	}

```
###### \src\org\jimple\planner\task\TaskSorter.java
``` java
public class TaskSorter {

	private static Comparator<Task> getFromDateTimeComparator(){
		return new Comparator<Task>(){
			public int compare(Task task1, Task task2){
				return task1.getFromTime().compareTo(task2.getFromTime());
			}
		};
	}

	private static Comparator<Task> getFromDateComparator(){
		return new Comparator<Task>(){
			public int compare(Task task1, Task task2){
				return task1.getFromTime().toLocalDate().compareTo(task2.getFromTime().toLocalDate());
			}
		};
	}

	private static Comparator<Task> getTaskIdComparator(){
		return new Comparator<Task>(){
			public int compare(Task task1, Task task2){
				int task1id = task1.getTaskId();
				int task2id = task2.getTaskId();
				int result;
				if(task1id<task2id){
					result = -1;
				} else if (task1id==task2id){
					result = 0;
				} else {
					result = 1;
				}
				return result;
			}
		};
	}

	private static void sortDeadlines(ArrayList<Task> deadlineList){
		Comparator<Task> fromDateComparator = getFromDateTimeComparator();
		Collections.sort(deadlineList, fromDateComparator);
	}

	private static void sortEvents(ArrayList<Task> eventList){
		Comparator<Task> fromDateComparator = getFromDateTimeComparator();
		Collections.sort(eventList, fromDateComparator);
	}

	private static void sortById(ArrayList<ArrayList<Task>> allTaskLists){
		Comparator<Task> taskIdComparator = getTaskIdComparator();
		for(ArrayList<Task> taskList: allTaskLists){
			Collections.sort(taskList, taskIdComparator);
		}
	}

	public void sortTasks(ArrayList<ArrayList<Task>> allTaskLists){
		assert allTaskLists.size() == 4;
		sortById(allTaskLists);
		sortDeadlines(allTaskLists.get(1));
		sortEvents(allTaskLists.get(2));
	}

	public void sortTasksByTime(ArrayList<Task> list){
		Collections.sort(list, getFromDateComparator());
	}
}
```
###### \src\org\jimple\planner\test\AllTestSuites.java
``` java
@RunWith(Suite.class)
@SuiteClasses({ 
	StorageTestSuite.class,
	ParserTest.class,
	LogicTestSuite.class,
	TaskTest.class
})

public class AllTestSuites {

}
```
###### \src\org\jimple\planner\test\storage\StorageTestGetFromLine.java
``` java
public class StorageTestGetFromLine {
	private StorageLoad loadUnit = new StorageLoad();
	/*
	 * These tests are for testing the parsing of each String as written as a line inside the file itself and making sure
	 * it returns the correct Task instance that goes along with this
	 */
	
	@Test
	//random sample of tasks in a normal situation
```
###### \src\org\jimple\planner\test\storage\StorageTestGetFromLine.java
``` java
	public void testGetTaskFromLine1(){
		LinkedList<Task> tasks = new LinkedList<Task>();
		
		String line1 = "/s/:title:Go exercise, you fatty/s//s/:desc:Keep fit/s//s/:label:/tl/Exercise Time/tl//tl/3/tl//s/";
		String line2 = "/s/:title:register for Orbital/s//s/:desc:keep my summer occupied/s//s/:from:2016-05-15T16:00/s/";
		String line3 = "/s/:title:Attend seminar/s//s/:desc:at SOC/s//s/:from:2016-08-11T11:00/s//s/:to:2016-08-11T17:00/s/";
		String line4 = "/s/:title:banana king/s//s/:desc:tomahawk/s//s/:from:2016-08-11T11:00/s/";
		String line5 = "/s/:title:attend wedding/s//s/:from:2016-03-15T15:00/s/";
		
		tasks.add(loadUnit.testGetTaskFromLine(line1));
		tasks.add(loadUnit.testGetTaskFromLine(line2));
		tasks.add(loadUnit.testGetTaskFromLine(line3));
		tasks.add(loadUnit.testGetTaskFromLine(line4));
		tasks.add(loadUnit.testGetTaskFromLine(line5));
		
		String title1 = tasks.get(0).getTitle();
		String desc1 = tasks.get(0).getDescription();
		String from1 = tasks.get(0).getFromTimeString();
		String to1 = tasks.get(0).getToTimeString();
		String type1 = tasks.get(0).getType();
		String labelName1 = tasks.get(0).getTaskLabel().getLabelName();
		int labelColourId1 = tasks.get(0).getTaskLabel().getColourId();
		assertEquals("title", "Go exercise, you fatty", title1);
		assertEquals("desc", "Keep fit", desc1);
		assertEquals("from", "", from1);
		assertEquals("to", "", to1);
		assertEquals("type", "floating", type1);
		assertEquals("labelName", "Exercise Time", labelName1);
		assertEquals("labelColourId", 3, labelColourId1);
		
		String title2 = tasks.get(1).getTitle();
		String desc2 = tasks.get(1).getDescription();
		String from2 = tasks.get(1).getFromTimeString();
		String to2 = tasks.get(1).getToTimeString();
		String type2 = tasks.get(1).getType();
		assertEquals("title", "register for Orbital", title2);
		assertEquals("desc", "keep my summer occupied", desc2);
		assertEquals("from", "2016-05-15T16:00", from2);
		assertEquals("to", "", to2);
		assertEquals("type", "deadline", type2);
			
		String title3 = tasks.get(2).getTitle();
		String desc3 = tasks.get(2).getDescription();
		String from3 = tasks.get(2).getFromTimeString();
		String to3 = tasks.get(2).getToTimeString();
		String type3 = tasks.get(2).getType();
		assertEquals("title", "Attend seminar", title3);
		assertEquals("desc", "at SOC", desc3);
		assertEquals("from", "2016-08-11T11:00", from3);
		assertEquals("to", "2016-08-11T17:00", to3);
		assertEquals("type", "event", type3);
		
		String title4 = tasks.get(3).getTitle();
		String desc4 = tasks.get(3).getDescription();
		String from4 = tasks.get(3).getFromTimeString();
		String to4 = tasks.get(3).getToTimeString();
		String type4 = tasks.get(3).getType();
		assertEquals("title", "banana king", title4);
		assertEquals("desc", "tomahawk", desc4);
		assertEquals("from", "2016-08-11T11:00", from4);
		assertEquals("to", "", to4);
		assertEquals("type", "deadline", type4);
		
		String title5 = tasks.get(4).getTitle();
		String desc5 = tasks.get(4).getDescription();
		String from5 = tasks.get(4).getFromTimeString();
		String to5 = tasks.get(4).getToTimeString();
		String type5 = tasks.get(4).getType();
		assertEquals("title", "attend wedding", title5);
		assertEquals("desc", "", desc5);
		assertEquals("from", "2016-03-15T15:00", from5);
		assertEquals("to", "", to5);
		assertEquals("type", "deadline", type5);
	}
	
	@Test
	public void testGetTaskFromLine2(){
		String line1 = "/s/:title:task1/s/";
		String line2 = "/s/:title:task1/s//s/:to:2016-08-11T17:00/s/";
		String line3 = "/s/:title:task1/s//s/:from:2016-08-11T11:00/s//s/:to:2016-08-11T17:00/s/";
		String line4 = "/s/:title:task1/s//s/:from:2016-08-11T11:00/s/";
		
		Task task1 = loadUnit.testGetTaskFromLine(line1);
		Task task2 = loadUnit.testGetTaskFromLine(line2);
		Task task3 = loadUnit.testGetTaskFromLine(line3);
		Task task4 = loadUnit.testGetTaskFromLine(line4);
		
		assertTrue("valid task", task1.isValidType());
		assertFalse("invalid task", task2.isValidType());
		assertTrue("valid task", task3.isValidType());
		assertTrue("valid task", task4.isValidType());
		
		assertEquals("is todo", task1.getType(), TYPE_TODO);
		assertEquals("is event", task3.getType(), TYPE_EVENT);
		assertEquals("is deadline", task4.getType(), TYPE_DEADLINE);
	}
}
```
###### \src\org\jimple\planner\test\storage\StorageTestSaveLoadMechanics.java
``` java
public class StorageTestSaveLoadMechanics {
	private StorageSave saveUnit = new StorageSave();
	private StorageLoad loadUnit = new StorageLoad();
	
	/*
	 * This tests the retrieval and saving of tasks
	 */
```
###### \src\org\jimple\planner\test\storage\StorageTestSaveLoadMechanics.java
``` java
	@Test
	public void testSavingAndRetrieval() throws IOException{
		testIsSaved();
		testGetTasks();
	}
	@After // tearDown()
	public void after() throws Exception {
		System.out.println("Running: tearDown");
		String testFileName = "jimpleFiles"+File.separator+"testplanner.jim";
		String tempTestFileName = "jimpleFiles"+File.separator+"testtempplanner.jim";
		File testFile = new File(testFileName);
		testFile.delete();
		File tempTestFile = new File(tempTestFileName);
		tempTestFile.delete();
		assertFalse("test file deleted successfully", testFile.exists());
		assertFalse("test file deleted successfully", tempTestFile.exists());
	}
	
	public void testIsSaved() throws IOException {
		ArrayList<ArrayList<Task>> tasks = StorageGetExampleTasks.getExampleTasks();
		boolean saveState = saveUnit.isSavedTasksTest(tasks);
		assertTrue("this should return true if saved", saveState);
	}
	
	public void testGetTasks() throws IOException{
		ArrayList<ArrayList<Task>> tasks = loadUnit.getTestTasks();
		ArrayList<Task> floating = tasks.get(0);
		ArrayList<Task> deadline = tasks.get(1);
		ArrayList<Task> event = tasks.get(2);
		
		String[] floating1Check = {"Go exercise, you fatty", "Keep fit"};
		String[] floating2Check = {"Read Lord of The Rings"};
		String[] floating3Check = {"Learn to play the harmonica"};
		String[] floating4Check = {"go through my anime backlog"};
		String floating1Title = floating.get(0).getTitle();
		String floating2Title = floating.get(1).getTitle();
		String floating3Title = floating.get(2).getTitle();
		String floating4Title = floating.get(3).getTitle();
		assertEquals("true if same", floating1Check[0], floating1Title);
		assertEquals("true if same", floating2Check[0], floating2Title);
		assertEquals("true if same", floating3Check[0], floating3Title);
		assertEquals("true if same", floating4Check[0], floating4Title);
		
		String[] deadline3Check = {"submit report before countdown party", "2015-12-31T23:59"};
		String[] deadline4Check = {"deadline for GER1000 quiz", "2016-03-06T23:59"};
		String[] deadline2Check = {"Hand in cs2103 progress report", "Homework", "2016-03-09T23:59"}; //homework is cate
		String[] deadline5Check = {"register for Orbital", "keep my summer occupied", "Self-learning", "2016-05-15T16:00"};
		String[] deadline1Check = {"Do 2100 assignment", "due very soon", "Homework", "2016-07-29T23:59"};
		String deadline1Title = deadline.get(0).getTitle();
		String deadline1ToTime = deadline.get(0).getFromTimeString();
		String deadline2Title = deadline.get(1).getTitle();
		String deadline2ToTime = deadline.get(1).getFromTimeString();
		String deadline3Title = deadline.get(2).getTitle();
		String deadline3ToTime = deadline.get(2).getFromTimeString();
		String deadline4Title = deadline.get(3).getTitle();
		String deadline4ToTime = deadline.get(3).getFromTimeString();
		String deadline4Description = deadline.get(3).getDescription();
		String deadline5Title = deadline.get(4).getTitle();
		String deadline5ToTime = deadline.get(4).getFromTimeString();
		String deadline5Description = deadline.get(4).getDescription();

		assertEquals("true if same", deadline3Check[0], deadline1Title);
		assertEquals("true if same", deadline3Check[1], deadline1ToTime);
		assertEquals("true if same", deadline4Check[0], deadline2Title);
		assertEquals("true if same", deadline4Check[1], deadline2ToTime);
		assertEquals("true if same", deadline2Check[0], deadline3Title);
		assertEquals("true if same", deadline2Check[2], deadline3ToTime);
		assertEquals("true if same", deadline5Check[0], deadline4Title);
		assertEquals("true if same", deadline5Check[3], deadline4ToTime);
		assertEquals("true if same", deadline5Check[1], deadline4Description);
		assertEquals("true if same", deadline1Check[0], deadline5Title);
		assertEquals("true if same", deadline1Check[3], deadline5ToTime);
		assertEquals("true if same", deadline1Check[1], deadline5Description);
		
		String[] event2Check = {"eat with the bros", "the same place", "default 0", "2016-01-10T15:00", "2016-01-10T17:00"};
		String[] event5Check = {"prepare for chap goh mei dinner", "", "default 0", "2016-02-16T12:00", "2016-02-16T15:00"};
		String[] event1Check = {"Makan here for chap goh mei", "at cousin's place", "default 0", "2016-02-16T19:00", "2016-02-16T22:00"};
		String[] event4Check = {"business workshop", "", "default 0", "2016-06-16T12:00", "2016-06-16T14:00"};
		String[] event3Check = {"Attend seminar", "at SOC", "default 0", "2016-08-11T11:00", "2016-08-11T17:00"};
		
		String[] event1Actual = loadUnit.testExtractTasksToStringArray(event.get(0));
		String[] event2Actual = loadUnit.testExtractTasksToStringArray(event.get(1));
		String[] event3Actual = loadUnit.testExtractTasksToStringArray(event.get(2));
		String[] event4Actual = loadUnit.testExtractTasksToStringArray(event.get(3));
		String[] event5Actual = loadUnit.testExtractTasksToStringArray(event.get(4));
		for(int i=0; i<5; i++){
			assertEquals("true if same", event2Check[i], event1Actual[i]);
		}
		for(int i=0; i<5; i++){
			assertEquals("true if same", event5Check[i], event2Actual[i]);
		}
		for(int i=0; i<5; i++){
			assertEquals("true if same", event1Check[i], event3Actual[i]);
		}
		for(int i=0; i<5; i++){
			assertEquals("true if same", event4Check[i], event4Actual[i]);
		}
		for(int i=0; i<5; i++){
			assertEquals("true if same", event3Check[i], event5Actual[i]);
		}
	}
}
```
###### \src\org\jimple\planner\test\storage\StorageTestSuite.java
``` java
@RunWith(Suite.class)
@SuiteClasses({ 
	StorageTestGetFromLine.class,
	StorageTestSaveLoadMechanics.class,
	StorageTestWriteTask.class })

public class StorageTestSuite {

}
```
###### \src\org\jimple\planner\test\storage\StorageTestWriteTask.java
``` java
public class StorageTestWriteTask {
	private StorageSave storageSave = new StorageSave();
	
	/*
	 * The purpose of this test is to see how tasks are written in an environment that does not save to a file directly
	 * each String in linesToCheck represent 1 task from the example of tasks given from getExampleTasks
	 */
```
###### \src\org\jimple\planner\test\storage\StorageTestWriteTask.java
``` java
	@Test
	public void writeTasksTest1() {
		String[] linesToCheck = {
				"/s/:isDone:false/s//s/:title:Go exercise, you fatty/s//s/:desc:Keep fit/s/",
				"/s/:isDone:false/s//s/:title:Read Lord of The Rings/s/",
				"/s/:isDone:false/s//s/:title:Learn to play the harmonica/s/",
				"/s/:isDone:false/s//s/:title:go through my anime backlog/s/",
				"/s/:isDone:false/s//s/:title:submit report before countdown party/s//s/:from:2015-12-31T23:59/s/",
				"/s/:isDone:false/s//s/:title:deadline for GER1000 quiz/s//s/:from:2016-03-06T23:59/s/",
				"/s/:isDone:false/s//s/:title:Hand in cs2103 progress report/s//s/:desc:Homework/s//s/:from:2016-03-09T23:59/s/",
				"/s/:isDone:false/s//s/:title:register for Orbital/s//s/:desc:keep my summer occupied/s//s/:from:2016-05-15T16:00/s/",
				"/s/:isDone:false/s//s/:title:Do 2100 assignment/s//s/:desc:due very soon/s//s/:from:2016-07-29T23:59/s/",
				"/s/:isDone:false/s//s/:title:eat with the bros/s//s/:desc:the same place/s//s/:from:2016-01-10T15:00/s//s/:to:2016-01-10T17:00/s/",
				"/s/:isDone:false/s//s/:title:prepare for chap goh mei dinner/s//s/:from:2016-02-16T12:00/s//s/:to:2016-02-16T15:00/s/",
				"/s/:isDone:false/s//s/:title:Makan here for chap goh mei/s//s/:desc:at cousin's place/s//s/:from:2016-02-16T19:00/s//s/:to:2016-02-16T22:00/s/",
				"/s/:isDone:false/s//s/:title:business workshop/s//s/:from:2016-06-16T12:00/s//s/:to:2016-06-16T14:00/s/",
				"/s/:isDone:false/s//s/:title:Attend seminar/s//s/:desc:at SOC/s//s/:from:2016-08-11T11:00/s//s/:to:2016-08-11T17:00/s/"

		};
		StringWriter sw = new StringWriter();
		BufferedWriter output = new BufferedWriter(sw);
		ArrayList<ArrayList<Task>> tasks = StorageGetExampleTasks.getExampleTasks();
		storageSave.testWriteTasks(tasks, output);
		String totalOutput = sw.toString();
		String[] totalOutputArray = totalOutput.split(System.getProperty("line.separator"));
		String message1 = "String[] should be equal, "+String.valueOf(totalOutputArray.length)+" "+String.valueOf(linesToCheck.length);
		assertEquals(message1, totalOutputArray.length, linesToCheck.length);
		for(int i=0; i<totalOutputArray.length; i++){
			String message2 = "line " + String.valueOf(i);
			assertEquals(message2, totalOutputArray[i], linesToCheck[i]);
		}
	}
	
	//Boundary case, when all lists are empty
	@Test
	public final void writeTasksTest2(){
		StringWriter sw = new StringWriter();
		BufferedWriter output = new BufferedWriter(sw);
		ArrayList<ArrayList<Task>> tasks = new ArrayList<ArrayList<Task>>();
		tasks.add(new ArrayList<Task>());
		tasks.add(new ArrayList<Task>());
		tasks.add(new ArrayList<Task>());
		tasks.add(new ArrayList<Task>());
		storageSave.testWriteTasks(tasks, output);
		String totalOutput = sw.toString();
		assertEquals("Should be empty", totalOutput, "");
	}

}
```
