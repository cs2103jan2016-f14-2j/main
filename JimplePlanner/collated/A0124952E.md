# A0124952E
###### \src\org\jimple\planner\constants\Constants.java
``` java
	public static final String STRING_SEARCH = "SEARCH";
	public static final String STRING_ADD = "ADD";
	public static final String STRING_DELETE = "DELETE";
	public static final String STRING_EDIT = "EDIT";
	public static final String STRING_CHANGEDIR = "CHANGEDIR";
	public static final String STRING_UNDOTASK = "UNDOTASK";
	public static final String STRING_HELP = "HELP";
	public static final String STRING_CHECKDIR = "CHECKDIR";
	public static final String STRING_EDITLABEL = "EDITLABEL";
	public static final String STRING_DELETELABEL = "DELETELABEL";
	public static final String STRING_DONE = "DONE";
	public static final String STRING_RETURN = "RETURN";
	public static final String STRING_CHECKCONFLICT = "CHECKCONFLICT";
	
	public static final String TIME_FORMAT_HELP_HEADER = "Time Format:\n";
	public static final String ADD_HELP_HEADER = "Add a new task:\n";
	public static final String EDIT_HELP_HEADER = "Edit a current task:\n";
	public static final String SEARCH_HELP_HEADER = "Search tasks:\n";
	public static final String DELETE_HELP_HEADER = "Delete a task:\n";
	public static final String UNDOTASK_HELP_HEADER = "Undo a task:\n";
	public static final String CHANGEDIR_HELP_HEADER = "Change Jimple File Directory:\n";
	public static final String CHECKDIR_HELP_HEADER = "Check Jimple File Directory:\n";
	public static final String EDITLABEL_HELP_HEADER = "Edit a label:\n";
	public static final String DELETELABEL_HELP_HEADER = "Delete a label:\n";
	public static final String ARCHIVE_HELP_HEADER = "Archive completed tasks:\n";
	public static final String UNARCHIVE_HELP_HEADER = "Return completed tasks:\n";
	public static final String CHECKCONFLICT_HELP_HEADER = "Check tasks in conflict:\n";
	
	public static final String TIME_FORMAT = "<date in DAY MONTH> / <time in day of week> / <time in AM/PM> / <time in 24HR>\n\n";
	
	public static final String ADD_COMMAND_BY = "type \"ADD\" <your event name> BY <time>\n";
	public static final String ADD_COMMAND_AT = "type \"ADD\" <your event name> AT <time>\n";
	public static final String ADD_COMMAND_ON = "type \"ADD\" <your event name> ON <time>\n";
	public static final String ADD_COMMAND_FROMTO = "type \"ADD\" <your event> FROM <time> TO <time>\n";
	public static final String ADD_COMMAND_DESC = "type \"ADD\" <your event name> \"DESC\" <your event description>\n";
	public static final String ADD_COMMAND_LABEL = "type \"ADD\" <your event name> \"LABEL\" <label name>\n\n";
	
	public static final String EDIT_COMMAND_NAME = "type \"EDIT\" <taskID> \"NAME\" <your event title>\n";
	public static final String EDIT_COMMAND_DESC = "type \"EDIT\" <taskID> \"DESC\" <your event description>\n";
	public static final String EDIT_COMMAND_BY_TIME = "type \"EDIT\" <taskID> \"TIME\" BY <date/time>\n";
	public static final String EDIT_COMMAND_FROMTO_TIME = "type \"EDIT\" <taskID> \"TIME\" FROM <date/time> TO <date/time>\n";
	public static final String EDIT_COMMAND_ON_TIME = "type \"EDIT\" <taskID> \"TIME\" ON <date/time>\n";
	public static final String EDIT_COMMAND_AT_TIME = "type \"EDIT\" <taskID> \"TIME\" AT <date/time>\n";
	public static final String EDIT_COMMAND_LABEL = "type \"EDIT\" <taskID> \"LABEL\" <new label name/\"default\" to remove label>\n\n";
	
	public static final String DELETE_COMMAND = "type \"DELETE\" <taskID>\n\n";
	
	public static final String SEARCH_COMMAND = "type \"SEARCH\" <task name>\n\n";
	
	public static final String UNDOTASK_COMMAND = "type \"UNDOTASK\"\n\n";
	
	public static final String CHANGEDIR_COMMAND = "type \"CHANGEDIR\" <full path directory>\n\n";
	public static final String CHECKDIR_COMMAND = "type \"CHECKDIR\"\n\n";
	
	public static final String EDITLABEL_COMMAND = "type \"EDITLABEL\" <old label name/colour> NAME <new label name> COLOUR <new label colour>\n\n";
	public static final String DELETELABEL_COMMAND = "type \"DELETELABEL\" <label name>\n\n";
	
	public static final String ARCHIVE_COMMAND = "type \"DONE\" <taskID>\n\n";
	public static final String UNARCHIVE_COMMAND = "type \"RETURN\" <taskID>\n\n";
	
	public static final String CHECKCONFLICT_COMMAND = "type \"CHECKCONFLICT\" <taskID>\n";
	
	public static final String ERROR_WRONG_INPUT_FEEDBACK = "wrong input format";
	public static final String ERROR_WRONG_COMMAND_FEEDBACK = "unknown command";
	
	public static final String ERROR_WRONG_TIME_FEEDBACK = "please input a valid \"from\" and \"to\" time";
	public static final String ADDED_FEEDBACK = " added to planner";
	
	public static final String UNDO_FEEDBACK = " undone";
	public static final String UNDO_FEEDBACK_ERROR = "no task to undo";
	
	public static final String EDITED_FEEDBACK = " edited in planner";
	public static final String ERROR_EDIT_FEEDBACK = " could not be edited";
	
	public static final String ERROR_DIRECTORY_PATH_FEEDBACK = "invalid directory path";
	public static final String DIRECTORY_PATH_CHANGED_FEEDBACK = "save directory path changed to ";
	
	public static final String DELETED_FEEDBACK = " deleted";
	public static final String ERROR_DELETED_FEEDBACK = " could not be found";
	
	public static final String LABEL_FEEDBACK = " label changed";
	public static final String ERROR_LABEL_FEEDBACK = "label could not be changed";
	
	public static final String LABEL_DELETED_FEEDBACK = "label is deleted";
	public static final String ERROR_LABEL_DELETED_FEEDBACK = "label could not be deleted";
	
	public static final String DONE_FEEDBACK = " is now archived";
	public static final String ERROR_DONE_FEEDBACK = " does not exist and could not be archived";
	
	public static final String UNDONE_FEEDBACK = " has returned to your list";
	public static final String ERROR_UNDONE_FEEDBACK = " could not be returned to your list";
	
	public static final String ERROR_NO_CONFLICT_FOUND = "no conflicts found";

	public static final int MAX_ID = 10000;
	public static final int DELETE_CACHE_LIMIT = 20;
	
	public static String WINDOW_CLOSED_FEEDBACK = "search window closed";
	
	private Constants(){
		throw new AssertionError();
	}
}
```
###### \src\org\jimple\planner\exceptions\InvalidFromAndToTimeException.java
``` java
@SuppressWarnings("serial")
public class InvalidFromAndToTimeException extends Exception {
	public InvalidFromAndToTimeException() {
	}
	
	public InvalidFromAndToTimeException(String message)	{
		super(message);
	}

}
```
###### \src\org\jimple\planner\logic\Logic.java
``` java
public class Logic implements LogicMasterListModification, LogicTaskModification {

	private ArrayList<Task> deadlines;
	private ArrayList<Task> todo;
	private ArrayList<Task> events;
	private ArrayList<Task> agenda;
	private ArrayList<Task> tempHistory;
	private ArrayList<Task> searchResults;
	private ArrayList<Task> archivedTasks;
	private ArrayList<Task> conflictedTasks;
	private ArrayList<String> pastUserInputs;
	private ArrayList<myObserver> observers;
	private ArrayList<TaskLabel> taskLabels;
	private LinkedList<LogicPreviousTask> undoTasks;
	private HashMap<Integer, Boolean> idHash;

	private Parser parser;
	private StorageInterface store;
	private LogicAdd adder;
	private LogicEdit editer;
	private LogicDelete deleter;
	private LogicSearch searcher;
	private LogicDirectory directer;
	private LogicUndo undoer;
	private LogicLabel labeler;
	private LogicArchive archiver;
	private LogicConflict conflictChecker;
	static Logger logger = Logger.getLogger(Logic.class.getName());

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public Logic() {
		agenda = new ArrayList<Task>();
		tempHistory = new ArrayList<Task>();
		searchResults = new ArrayList<Task>();
		archivedTasks = new ArrayList<Task>();
		conflictedTasks = new ArrayList<Task>();
		undoTasks = new LinkedList<LogicPreviousTask>();
		pastUserInputs = new ArrayList<String>();
		observers = new ArrayList<myObserver>();
		taskLabels = new ArrayList<TaskLabel>();
		idHash = new HashMap<Integer, Boolean>();
		parser = new Parser();
		store = new Storage();
		adder = new LogicAdd();
		editer = new LogicEdit();
		deleter = new LogicDelete();
		searcher = new LogicSearch();
		directer = new LogicDirectory();
		undoer = new LogicUndo();
		labeler = new LogicLabel();
		archiver = new LogicArchive();
		conflictChecker = new LogicConflict();
		try {
			initializeIDMap();
			ArrayList<ArrayList<Task>> allTasks = store.getTasks();
			taskLabels = store.getLabels();
			assignTaskIds(allTasks, idHash);
			LogicLinkLabelsToTasks.linkTasksToLabels(allTasks, taskLabels);
			todo = allTasks.get(0);
			deadlines = allTasks.get(1);
			events = allTasks.get(2);
			archivedTasks = allTasks.get(3);
			checkOverCurrentTime(deadlines, events);
			conflictChecker.checkForAllTasksIfConflictWithCurrentTasks(deadlines, events);
		} catch (IndexOutOfBoundsException e) {
			todo = new ArrayList<Task>();
			deadlines = new ArrayList<Task>();
			events = new ArrayList<Task>();
			logger.log(Level.FINER, e.toString(), e);
			logger.log(Level.FINER, "First initialization of jimple files");
		}
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	/**
	 * function is for the UI to call when a user inputs a string
	 */
	public void execute(String inputString) throws IOException {
		String[] feedback = new String[2];
		pastUserInputs.add(inputString);
		try {
			InputStruct parsedInput = parser.parseInput(inputString);
			switch (parsedInput.getCommand()) {
			case Constants.STRING_DELETE:
				feedback[0] = deleter.deleteTask(parsedInput.getVariableArray(), todo, deadlines, events, archivedTasks,
						undoTasks, idHash);
				feedback[1] = "";
				break;
			case Constants.STRING_ADD:
				feedback[0] = adder.addToTaskList(parsedInput.getVariableArray(), tempHistory, todo, deadlines, events,
						taskLabels, undoTasks, idHash);
				feedback[1] = getTaskTypeAndTaskID();
				break;
			case Constants.STRING_EDIT:
				feedback[0] = editer.editTask(parsedInput.getVariableArray(), todo, deadlines, events, archivedTasks, tempHistory,
						taskLabels, undoTasks, idHash);
				feedback[1] = getTaskTypeAndTaskID();
				break;
			case Constants.STRING_SEARCH:
				searchResults.clear();
				searchResults = searcher.searchWord(parsedInput.getVariableArray()[0], todo, deadlines, events,
						archivedTasks);
				feedback[0] = "";
				feedback[1] = Constants.TYPE_SEARCH;
				break;
			case Constants.STRING_CHANGEDIR:
				feedback[0] = directer.changeSaveDirectory(store, conflictChecker, parsedInput.getVariableArray(), todo,
						deadlines, events, archivedTasks, taskLabels, idHash);
				feedback[1] = "";
				break;
			case Constants.STRING_UNDOTASK:
				feedback[0] = undoer.undoPreviousChange(undoTasks, todo, deadlines, events, archivedTasks, tempHistory,
						taskLabels, idHash);
				feedback[1] = "";
				break;
			case Constants.STRING_HELP:
				feedback[0] = helpCommand();
				feedback[1] = Constants.TYPE_HELP;
				break;
			case Constants.STRING_CHECKDIR:
				feedback[0] = directer.checkPath(store);
				feedback[1] = "";
				break;
			case Constants.STRING_EDITLABEL:
				feedback[0] = labeler.changeLabel(parsedInput.getVariableArray(), taskLabels, todo, deadlines, events, archivedTasks);
				feedback[1] = "";
				break;
			case Constants.STRING_DELETELABEL:
				feedback[0] = labeler.deleteLabel(parsedInput.getVariableArray(), taskLabels, todo, deadlines, events,
						archivedTasks);
				feedback[1] = "";
				break;
			case Constants.STRING_DONE:
				feedback[0] = archiver.markTaskAsDone(parsedInput.getVariableArray(), undoTasks, tempHistory, todo,
						deadlines, events, archivedTasks, taskLabels);
				feedback[1] = getTaskID() + Constants.TYPE_ARCHIVE;
				break;
			case Constants.STRING_RETURN:
				feedback[0] = archiver.markTaskAsUndone(parsedInput.getVariableArray(), undoTasks, tempHistory, todo,
						deadlines, events, archivedTasks, taskLabels);
				feedback[1] = getTaskTypeAndTaskID();
				break;
			case Constants.STRING_CHECKCONFLICT:
				conflictedTasks = conflictChecker.getConflictedTasks(parsedInput.getVariableArray(), deadlines, events);
				feedback[0] = "";
				feedback[1] = Constants.TYPE_CONFLICTED;
				break;
			default:
				feedback[0] = Constants.ERROR_WRONG_COMMAND_FEEDBACK;
				feedback[1] = "";
				break;
			}
		} catch (DuplicateDateTimeFieldException dfe) {
			feedback[0] = dfe.getMessage();
			feedback[1] = "";
			/*logger.log(Level.WARNING, dfe.toString(), dfe);
			logger.log(Level.WARNING, dfe.getMessage());
			logger.log(Level.WARNING, "User input: " + inputString + "\n");*/
		} catch (InvalidCommandException ice) {
			feedback[0] = ice.getMessage();
			feedback[1] = "";
			/*logger.log(Level.WARNING, ice.toString(), ice);
			logger.log(Level.WARNING, ice.getMessage());
			logger.log(Level.WARNING, "User input: "+ inputString + "\n");*/
		} catch (InvalidDateTimeFieldException ife) {
			feedback[0] = ife.getMessage();
			feedback[1] = "";
			/*logger.log(Level.WARNING, ife.toString(), ife);
			logger.log(Level.WARNING, ife.getMessage());
			logger.log(Level.WARNING, "User input: "+ inputString + "\n");*/
		} catch (InvalidFromAndToTimeException ift) {
			feedback[0] = ift.getMessage();
			feedback[1] = "";
			logger.log(Level.WARNING, ift.toString(), ift);
			logger.log(Level.WARNING, ift.getMessage());
			logger.log(Level.WARNING, inputString + "\n");
		} catch (MissingDateTimeFieldException mfe) {
			feedback[0] = mfe.getMessage();
			feedback[1] = "";
			/*logger.log(Level.WARNING, mfe.toString(), mfe);
			logger.log(Level.WARNING, mfe.getMessage());
			logger.log(Level.WARNING, "User input: " + inputString + "\n");*/
		} catch (IOException io) {
			logger.log(Level.SEVERE, io.toString(), io);
			logger.log(Level.SEVERE, "Jimple files does not exist\n");
		} catch (Exception e) {
			feedback[0] = Constants.ERROR_WRONG_INPUT_FEEDBACK;
			feedback[1] = "";
			logger.log(Level.WARNING, e.toString(), e);
			logger.log(Level.WARNING, "Unhandled exception\n");
			logger.log(Level.WARNING, "User input: " + inputString + "\n");
		}
		conflictChecker.checkForAllTasksIfConflictWithCurrentTasks(deadlines, events);
		packageForSavingMasterLists(store, todo, deadlines, events, archivedTasks);
		packageForSavingLabelLists(store, taskLabels);
		notifyAllObservers(feedback);
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public ArrayList<Task> getSearchList() {
		searchResults.clear();
		searchResults = searcher.searchWord(LogicSearch.mostRecentlySearchedWord, todo, deadlines, events,
				archivedTasks);
		return searchResults;
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public ArrayList<Task> getAgendaList() {
		agenda.clear();
		checkOverCurrentTime(deadlines, events);
		ArrayList<Task> dividedTasks = getDividedTasks(events);
		agenda.addAll(deadlines);
		agenda.addAll(dividedTasks);
		Task.sortTasksByTime(agenda);
		return agenda;
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public String getPastInputs(int cmdHistoryPointer) {
		if (!pastUserInputs.isEmpty()) {
			return pastUserInputs.get(cmdHistoryPointer);
		}
		return "";
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	private String getTaskTypeAndTaskID() {
		if (!tempHistory.isEmpty()) {
			return Integer.toString(tempHistory.get(tempHistory.size() - 1).getTaskId())
					+ tempHistory.get(tempHistory.size() - 1).getType();
		} else {
			return "";
		}
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	private String getTaskID() {
		if (!tempHistory.isEmpty()) {
			return Integer.toString(tempHistory.get(tempHistory.size() - 1).getTaskId());
		} else {
			return "";
		}
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	private void initializeIDMap() {
		for (int i = 0; i < Constants.MAX_ID; i++) {
			idHash.put(i + 1, false);
		}
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public void attach(myObserver observer) {
		observers.add(observer);
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public void notifyAllObservers() {
		for (myObserver observer : observers) {
			observer.update();
		}
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public void notifyAllObservers(String[] displayType) {
		for (myObserver observer : observers) {
			observer.update(displayType);
		}
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	public void refreshLists() {
		final Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(60), new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				notifyAllObservers();
			}
		}));
		timeline.setCycleCount(Animation.INDEFINITE);
		timeline.play();
	}

```
###### \src\org\jimple\planner\logic\Logic.java
``` java
	/**
	 * gets a list of help commands for user to refer to
	 *
	 */
	private String helpCommand() {
		String listOfCommands = new String();
		listOfCommands += Constants.NEWLINE;
		listOfCommands += Constants.TIME_FORMAT_HELP_HEADER;
		listOfCommands += Constants.TIME_FORMAT;

		listOfCommands += Constants.ADD_HELP_HEADER;
		listOfCommands += Constants.ADD_COMMAND_BY;
		listOfCommands += Constants.ADD_COMMAND_AT;
		listOfCommands += Constants.ADD_COMMAND_ON;
		listOfCommands += Constants.ADD_COMMAND_FROMTO;
		listOfCommands += Constants.ADD_COMMAND_DESC;
		listOfCommands += Constants.ADD_COMMAND_LABEL;

		listOfCommands += Constants.EDIT_HELP_HEADER;
		listOfCommands += Constants.EDIT_COMMAND_NAME;
		listOfCommands += Constants.EDIT_COMMAND_DESC;
		listOfCommands += Constants.EDIT_COMMAND_BY_TIME;
		listOfCommands += Constants.EDIT_COMMAND_FROMTO_TIME;
		listOfCommands += Constants.EDIT_COMMAND_ON_TIME;
		listOfCommands += Constants.EDIT_COMMAND_AT_TIME;
		listOfCommands += Constants.EDIT_COMMAND_LABEL;

		listOfCommands += Constants.DELETE_HELP_HEADER;
		listOfCommands += Constants.DELETE_COMMAND;

		listOfCommands += Constants.SEARCH_HELP_HEADER;
		listOfCommands += Constants.SEARCH_COMMAND;

		listOfCommands += Constants.UNDOTASK_HELP_HEADER;
		listOfCommands += Constants.UNDOTASK_COMMAND;

		listOfCommands += Constants.CHANGEDIR_HELP_HEADER;
		listOfCommands += Constants.CHANGEDIR_COMMAND;

		listOfCommands += Constants.CHECKDIR_HELP_HEADER;
		listOfCommands += Constants.CHECKDIR_COMMAND;

		listOfCommands += Constants.EDITLABEL_HELP_HEADER;
		listOfCommands += Constants.EDITLABEL_COMMAND;

		listOfCommands += Constants.DELETELABEL_HELP_HEADER;
		listOfCommands += Constants.DELETELABEL_COMMAND;

		listOfCommands += Constants.ARCHIVE_HELP_HEADER;
		listOfCommands += Constants.ARCHIVE_COMMAND;

		listOfCommands += Constants.UNARCHIVE_HELP_HEADER;
		listOfCommands += Constants.UNARCHIVE_COMMAND;
		
		listOfCommands += Constants.CHECKCONFLICT_HELP_HEADER;
		listOfCommands += Constants.CHECKCONFLICT_COMMAND;

		return listOfCommands;
	}

}
```
###### \src\org\jimple\planner\logic\LogicAdd.java
``` java
public class LogicAdd implements LogicTaskModification, LogicMasterListModification {

```
###### \src\org\jimple\planner\logic\LogicAdd.java
``` java
	protected String addToTaskList(String[] parsedInput, ArrayList<Task> tempHistory, ArrayList<Task> todo,
			ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<TaskLabel> taskLabels,
			LinkedList<LogicPreviousTask> undoTasks, HashMap<Integer, Boolean> idHash)
					throws IOException, InvalidFromAndToTimeException {
		assert parsedInput.length == 6;
		Task newTask = new Task("");
		newTask = doEdit(parsedInput, newTask, taskLabels);
		if (!isFromAndToTimeCorrect(newTask)) {
			throw new InvalidFromAndToTimeException(Constants.ERROR_WRONG_TIME_FEEDBACK);
		}
		allocateCorrectTimeArray(newTask, todo, deadlines, events);
		LogicTaskModification.assignOneTaskId(newTask, idHash);
		tempHistory.add(newTask);
		undoTasks.add(setNewPreviousTask(Constants.STRING_ADD, newTask));
		return "\"" + parsedInput[1] + "\"" + Constants.ADDED_FEEDBACK;
	}

```
###### \src\org\jimple\planner\logic\LogicArchive.java
``` java
public class LogicArchive implements LogicMasterListModification, LogicTaskModification {
	
```
###### \src\org\jimple\planner\logic\LogicArchive.java
``` java
	protected String markTaskAsDone(String[] parsedInput, LinkedList<LogicPreviousTask> undoTasks,
			ArrayList<Task> tempHistory, ArrayList<Task> todo, ArrayList<Task> deadlines, ArrayList<Task> events,
			ArrayList<Task> archivedTasks, ArrayList<TaskLabel> taskLabels) {
		boolean isTodoMarked = false;
		boolean isDeadlinesMarked = false;
		boolean isEventsMarked = false;

		isTodoMarked = findTaskToMark(parsedInput, undoTasks, todo, archivedTasks, tempHistory);
		if (!isTodoMarked) {
			isDeadlinesMarked = findTaskToMark(parsedInput, undoTasks, deadlines, archivedTasks, tempHistory);
		}
		if (!isTodoMarked && !isDeadlinesMarked) {
			isEventsMarked = findTaskToMark(parsedInput, undoTasks, events, archivedTasks, tempHistory);
		}

		if (isTodoMarked || isDeadlinesMarked || isEventsMarked) {
			return "task " + parsedInput[0] + Constants.DONE_FEEDBACK;
		}

		return "task " + parsedInput[0] + Constants.ERROR_DONE_FEEDBACK;
	}
	
```
###### \src\org\jimple\planner\logic\LogicArchive.java
``` java
	private boolean findTaskToMark(String[] parsedInput, LinkedList<LogicPreviousTask> undoTasks, ArrayList<Task> list,
			ArrayList<Task> archivedTasks, ArrayList<Task> tempHistory) {
		if (!list.isEmpty()) {
			for (int i = 0; i < list.size(); i++) {
				if (list.get(i).getTaskId() == Integer.parseInt(parsedInput[0])) {
					Task anArchivedTask = list.remove(i);
					anArchivedTask.setIsDone(true);
					archivedTasks.add(anArchivedTask);
					undoTasks.add(setNewPreviousTask(Constants.STRING_DONE, anArchivedTask));
					tempHistory.add(anArchivedTask);
					return true;
				}
			}
		}
		return false;
	}
	
```
###### \src\org\jimple\planner\logic\LogicArchive.java
``` java
	protected String markTaskAsUndone(String[] parsedInput, LinkedList<LogicPreviousTask> undoTasks,
			ArrayList<Task> tempHistory, ArrayList<Task> todo, ArrayList<Task> deadlines, ArrayList<Task> events,
			ArrayList<Task> archivedTasks, ArrayList<TaskLabel> taskLabels) throws IOException {
		if (!archivedTasks.isEmpty()) {
			for (int i = 0; i < archivedTasks.size(); i++) {
				if (archivedTasks.get(i).getTaskId() == Integer.parseInt(parsedInput[0])) {
					Task returnedTask = archivedTasks.remove(i);
					returnedTask.setIsDone(false);
					allocateCorrectTimeArray(returnedTask, todo, deadlines, events);
					undoTasks.add(setNewPreviousTask(Constants.STRING_RETURN, returnedTask));
					tempHistory.add(returnedTask);
					return "task " + parsedInput[0] + Constants.UNDONE_FEEDBACK;
				}
			}
		}
		return "task " + parsedInput[0] + Constants.ERROR_UNDONE_FEEDBACK;
	}
	
```
###### \src\org\jimple\planner\logic\LogicConflict.java
``` java
public class LogicConflict {
	public static String[] mostRecentlyCheckedConflict = new String[1];
	
```
###### \src\org\jimple\planner\logic\LogicConflict.java
``` java
	protected void checkForAllTasksIfConflictWithCurrentTasks(ArrayList<Task> deadlines, ArrayList<Task> events) {
		for (Task aDeadline : deadlines) {
			aDeadline.getConflictedTasks().clear();
			checkIsConflictWithCurrentTasks(aDeadline, deadlines, events);
		}
		for (Task anEvent : events) {
			anEvent.getConflictedTasks().clear();
			checkIsConflictWithCurrentTasks(anEvent, deadlines, events);
		}
	}
	
```
###### \src\org\jimple\planner\logic\LogicConflict.java
``` java
	protected ArrayList<Task> getConflictedTasks(String[] parsedInput, ArrayList<Task> deadlines,
			ArrayList<Task> events) {
		ArrayList<Task> conflicts = new ArrayList<Task>();
		if (!deadlines.isEmpty() || !events.isEmpty()) {
			mostRecentlyCheckedConflict = parsedInput;
			for (Task aDeadline : deadlines) {
				if (aDeadline.getTaskId() == Integer.parseInt(parsedInput[0])) {
					conflicts = aDeadline.getConflictedTasks();
					break;
				}
			}
			for (Task anEvent : events) {
				if (anEvent.getTaskId() == Integer.parseInt(parsedInput[0])) {
					conflicts = anEvent.getConflictedTasks();
					break;
				}
			}
		}
		return conflicts;
	}
	
```
###### \src\org\jimple\planner\logic\LogicConflict.java
``` java
	private void checkIsConflictWithCurrentTasks(Task newTask, ArrayList<Task> deadlines, ArrayList<Task> events) {
		switch (newTask.getType()) {
		case Constants.TYPE_DEADLINE:
			if (!deadlines.isEmpty()) {
				for (int i = 0; i < deadlines.size(); i++) {
					if (newTask.getFromTime().equals(deadlines.get(i).getFromTime())
							&& newTask.getTaskId() != deadlines.get(i).getTaskId()) {
						newTask.getConflictedTasks().add(deadlines.get(i));
//						deadlines.get(i).getConflictedTasks().add(newTask);
					}
				}
			}
			break;
		case Constants.TYPE_EVENT:
			if (!events.isEmpty()) {
				for (int i = 0; i < events.size(); i++) {
					if ((isToTimeExceedTimeRange(newTask, events.get(i))
							|| isFromTimeExceedTimeRange(newTask, events.get(i))
							|| isFromAndToTimeEncompassTimeRange(newTask, events.get(i)))
							&& newTask.getTaskId() != events.get(i).getTaskId()) {
						newTask.getConflictedTasks().add(events.get(i));
//						events.get(i).getConflictedTasks().add(newTask);
					}
				}
			}
			break;
		}
	}
	
```
###### \src\org\jimple\planner\logic\LogicConflict.java
``` java
	private boolean isToTimeExceedTimeRange(Task newTask, Task event) {
		if (newTask.getToTime().compareTo(event.getFromTime()) > 0
				&& newTask.getToTime().compareTo(event.getToTime()) < 0) {
			return true;
		}
		return false;
	}

```
###### \src\org\jimple\planner\logic\LogicConflict.java
``` java
	private boolean isFromTimeExceedTimeRange(Task newTask, Task event) {
		if (newTask.getFromTime().compareTo(event.getFromTime()) > 0
				&& newTask.getFromTime().compareTo(event.getToTime()) < 0) {
			return true;
		}
		return false;
	}
	
```
###### \src\org\jimple\planner\logic\LogicConflict.java
``` java
	private boolean isFromAndToTimeEncompassTimeRange(Task newTask, Task event) {
		if (newTask.getFromTime().compareTo(event.getFromTime()) <= 0
				&& newTask.getToTime().compareTo(event.getToTime()) >= 0) {
			return true;
		}
		return false;
	}

}
```
###### \src\org\jimple\planner\logic\LogicDelete.java
``` java
public class LogicDelete implements LogicTaskModification, LogicMasterListModification {
	
```
###### \src\org\jimple\planner\logic\LogicDelete.java
``` java
	protected String deleteTask(String[] variableArray, ArrayList<Task> todo, ArrayList<Task> deadlines,
			ArrayList<Task> events, ArrayList<Task> archivedTasks, LinkedList<LogicPreviousTask> undoTasks,
			HashMap<Integer, Boolean> idHash) throws IOException {
		boolean isFloatDeleted = false;
		boolean isDeadlineDeleted = false;
		boolean isEventsDeleted = false;
		boolean isArchivedDeleted = false;

		isFloatDeleted = findTaskToDelete(variableArray, todo, undoTasks, idHash);
		if (!isFloatDeleted) {
			isDeadlineDeleted = findTaskToDelete(variableArray, deadlines, undoTasks, idHash);
		}
		if (!isFloatDeleted && !isDeadlineDeleted) {
			isEventsDeleted = findTaskToDelete(variableArray, events, undoTasks, idHash);
		}
		if (!isFloatDeleted && !isDeadlineDeleted && !isEventsDeleted) {
			isArchivedDeleted = findTaskToDelete(variableArray, archivedTasks, undoTasks, idHash);
		}
		if (isFloatDeleted || isDeadlineDeleted || isEventsDeleted || isArchivedDeleted) {
			return "task " + variableArray[0] + Constants.DELETED_FEEDBACK;
		}
		return "task " + variableArray[0] + Constants.ERROR_DELETED_FEEDBACK;
	}
	
```
###### \src\org\jimple\planner\logic\LogicDelete.java
``` java
	private boolean findTaskToDelete(String[] variableArray, ArrayList<Task> list,
			LinkedList<LogicPreviousTask> undoTasks, HashMap<Integer, Boolean> idHash) throws IOException {
		for (int i = 0; i < list.size(); i++) {
			if (Integer.parseInt(variableArray[0]) == list.get(i).getTaskId()) {
				checkOverCacheLimit(undoTasks);
				Task removedTask = list.remove(i);
				removeTaskId(removedTask, idHash);
				// checkIfConflictedTaskExistInList(list, removedTask);
				undoTasks.add(setNewPreviousTask(Constants.STRING_DELETE, removedTask));
				return true;
			}
		}
		return false;
	}
	
```
###### \src\org\jimple\planner\logic\LogicDirectory.java
``` java
public class LogicDirectory implements LogicMasterListModification, LogicTaskModification {
	
```
###### \src\org\jimple\planner\logic\LogicDirectory.java
``` java
	protected String changeSaveDirectory(StorageInterface store, LogicConflict conflictChecker, String[] variableArray,
			ArrayList<Task> todo, ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks,
			ArrayList<TaskLabel> taskLabels, HashMap<Integer, Boolean> idHash) {
		if (!isValidPath(store, variableArray)) {
			return Constants.ERROR_DIRECTORY_PATH_FEEDBACK;
		}
		ArrayList<ArrayList<Task>> allTasks = store.getTasks();
		taskLabels = store.getLabels();
		assignTaskIds(allTasks, idHash);
		LogicLinkLabelsToTasks.linkTasksToLabels(allTasks, taskLabels);
		todo.clear();
		todo.addAll(allTasks.get(0));
		deadlines.clear();
		deadlines.addAll(allTasks.get(1));
		events.clear();
		events.addAll(allTasks.get(2));
		archivedTasks.clear();
		archivedTasks.addAll(allTasks.get(3));
		checkOverCurrentTime(deadlines, events);
		conflictChecker.checkForAllTasksIfConflictWithCurrentTasks(deadlines, events);
		return Constants.DIRECTORY_PATH_CHANGED_FEEDBACK + "\"" + variableArray[0] + "\"";
	}
	
```
###### \src\org\jimple\planner\logic\LogicDirectory.java
``` java
	protected String checkPath(StorageInterface store) {
		return store.checkPath();
	}
	
```
###### \src\org\jimple\planner\logic\LogicDirectory.java
``` java
	private boolean isValidPath(StorageInterface store, String[] variableArray) {
		if (store.setPath(variableArray[0])) {
			return true;
		}
		return false;
	}

}
```
###### \src\org\jimple\planner\logic\LogicEdit.java
``` java
public class LogicEdit implements LogicTaskModification, LogicMasterListModification {

```
###### \src\org\jimple\planner\logic\LogicEdit.java
``` java
	protected String editTask(String[] variableArray, ArrayList<Task> todo, ArrayList<Task> deadlines,
			ArrayList<Task> events, ArrayList<Task> archivedTasks, ArrayList<Task> tempHistory,
			ArrayList<TaskLabel> taskLabels, LinkedList<LogicPreviousTask> undoTasks, HashMap<Integer, Boolean> idHash)
					throws IOException, InvalidFromAndToTimeException {
		boolean isToDoEdited = false;
		boolean isWholeDayEdited = false;
		boolean isEventsEdited = false;
		boolean isArchivedEdited = false;

		isToDoEdited = findTaskToEdit(variableArray, todo, todo, deadlines, events, archivedTasks, tempHistory,
				taskLabels, undoTasks, idHash);
		if (!isToDoEdited) {
			isWholeDayEdited = findTaskToEdit(variableArray, deadlines, todo, deadlines, events, archivedTasks,
					tempHistory, taskLabels, undoTasks, idHash);
		}
		if (!isWholeDayEdited && !isToDoEdited) {
			isEventsEdited = findTaskToEdit(variableArray, events, todo, deadlines, events, archivedTasks, tempHistory,
					taskLabels, undoTasks, idHash);
		}
		if (!isWholeDayEdited && !isToDoEdited && !isEventsEdited) {
			isArchivedEdited = findTaskToEdit(variableArray, archivedTasks, todo, deadlines, events, archivedTasks, tempHistory, taskLabels,
					undoTasks, idHash);
		}
		if (isToDoEdited || isWholeDayEdited || isEventsEdited || isArchivedEdited) {
			return "task " + variableArray[0] + Constants.EDITED_FEEDBACK;
		}
		return "task " + variableArray[0] + Constants.ERROR_EDIT_FEEDBACK;
	}

```
###### \src\org\jimple\planner\logic\LogicEdit.java
``` java
	protected boolean findTaskToEdit(String[] variableArray, ArrayList<Task> list, ArrayList<Task> todo,
			ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks,
			ArrayList<Task> tempHistory, ArrayList<TaskLabel> taskLabels, LinkedList<LogicPreviousTask> undoTasks,
			HashMap<Integer, Boolean> idHash) throws IOException, InvalidFromAndToTimeException {
		for (int i = 0; i < list.size(); i++) {
			if (Integer.parseInt(variableArray[0]) == list.get(i).getTaskId()) {
				Task taskToBeEdited = list.remove(i);
				Task editedTask = doEdit(variableArray, taskToBeEdited, taskLabels);
				if (!isFromAndToTimeCorrect(editedTask)) {
					list.add(taskToBeEdited);
					throw new InvalidFromAndToTimeException(Constants.ERROR_WRONG_TIME_FEEDBACK);
				}
				tempHistory.add(taskToBeEdited);
				undoTasks.add(setNewPreviousTask(Constants.STRING_EDIT, editedTask));

				if (!editedTask.getIsDone()) {
					allocateCorrectTimeArray(editedTask, todo, deadlines, events);
				} else if (editedTask.getIsDone()) {
					archivedTasks.add(editedTask);
				}
				return true;
			}
		}
		return false;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
public class LogicLabel implements LogicMasterListModification, LogicTaskModification {
	HashMap<String, Integer> colourToIDMap = new HashMap<String, Integer>();
	HashMap<Integer, String> iDToColourMap = new HashMap<Integer, String>();
	
```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	public LogicLabel() {
		colourToIDMap.put("blue", 1);
		colourToIDMap.put("green", 2);
		colourToIDMap.put("yellow", 3);
		colourToIDMap.put("orange", 4);
		colourToIDMap.put("red", 5);
		colourToIDMap.put("purple", 6);
		iDToColourMap.put(1, "blue");
		iDToColourMap.put(2, "green");
		iDToColourMap.put(3, "yellow");
		iDToColourMap.put(4, "orange");
		iDToColourMap.put(5, "red");
		iDToColourMap.put(6, "purple");
	}
	
```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	protected String changeLabel(String[] variableArray, ArrayList<TaskLabel> taskLabels, ArrayList<Task> todo,
			ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks) throws IOException {
		if (isName(variableArray[0], taskLabels)) {
			int labelPosition = getLabelPosition(variableArray, taskLabels, "name");
			boolean isLabelChanged = isChangeLabel(variableArray, taskLabels, labelPosition, todo, deadlines, events, archivedTasks);
			if (isLabelChanged) {
				return variableArray[0] + Constants.LABEL_FEEDBACK;
			}
		} else if (isColour(variableArray[0], taskLabels)) {
			int labelPosition = getLabelPosition(variableArray, taskLabels, "colour");
			boolean isLabelChanged = isChangeLabel(variableArray, taskLabels, labelPosition, todo, deadlines, events, archivedTasks);
			if (isLabelChanged) {
				return variableArray[0] + Constants.LABEL_FEEDBACK;
			}
		}
		return Constants.ERROR_LABEL_FEEDBACK;
	}
	
```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	protected String deleteLabel(String[] variableArray, ArrayList<TaskLabel> taskLabels, ArrayList<Task> todo,
			ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks) throws IOException {
		for (int i = 0; i < taskLabels.size(); i++) {
			if (variableArray[0].equals(taskLabels.get(i).getLabelName())) {
				TaskLabel removedTask = taskLabels.remove(i);
				removeLabelsFromMasterList(todo, deadlines, events, archivedTasks, removedTask);
				return Constants.LABEL_DELETED_FEEDBACK;
			}
		}
		return Constants.ERROR_LABEL_DELETED_FEEDBACK;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private void removeLabelsFromMasterList(ArrayList<Task> todo, ArrayList<Task> deadlines, ArrayList<Task> events,
			ArrayList<Task> archivedTasks, TaskLabel removedTask) {
		for (int j = 0; j < todo.size(); j++) {
			if (todo.get(j).getTaskLabel().getLabelName().equals(removedTask.getLabelName())) {
				todo.get(j).setTaskLabel(TaskLabel.createDefaultLabel());
			}
		}
		for (int j = 0; j < deadlines.size(); j++) {
			if (deadlines.get(j).getTaskLabel().getLabelName().equals(removedTask.getLabelName())) {
				deadlines.get(j).setTaskLabel(TaskLabel.createDefaultLabel());
			}
		}
		for (int j = 0; j < events.size(); j++) {
			if (events.get(j).getTaskLabel().getLabelName().equals(removedTask.getLabelName())) {
				events.get(j).setTaskLabel(TaskLabel.createDefaultLabel());
			}
		}
		for (int j = 0; j < archivedTasks.size(); j++) {
			if (archivedTasks.get(j).getTaskLabel().getLabelName().equals(removedTask.getLabelName())) {
				archivedTasks.get(j).setTaskLabel(TaskLabel.createDefaultLabel());
			}
		}
	}
	
```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private int getLabelPosition(String[] variableArray, ArrayList<TaskLabel> taskLabels, String type) {
		for (int i = 0; i < taskLabels.size(); i++) {
			if (type.equals("colour")) {
				if (colourToIDMap.get(variableArray[0]).equals(taskLabels.get(i).getColourId())) {
					return taskLabels.get(i).getLabelId();
				}
			} else if (type.equals("name")) {
				if (variableArray[0].equals(taskLabels.get(i).getLabelName())) {
					return taskLabels.get(i).getLabelId();
				}
			}
		}
		return -1;
	}
	
```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private boolean isColour(String firstString, ArrayList<TaskLabel> taskLabels) {
		if (!taskLabels.isEmpty()) {
			if (colourToIDMap.containsKey(firstString)) {
				for (int i = 0; i < taskLabels.size(); i++) {
					if (colourToIDMap.get(firstString).equals(taskLabels.get(i).getColourId())) {
						return true;
					}
				}
			}
		}
		return false;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private boolean isName(String firstString, ArrayList<TaskLabel> taskLabels) {
		if (!taskLabels.isEmpty()) {
			for (TaskLabel aLabel : taskLabels) {
				if (firstString.equals(aLabel.getLabelName())) {
					return true;
				}
			}
		}
		return false;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private boolean isChangeLabel(String[] variableArray, ArrayList<TaskLabel> taskLabels, int labelPosition,
			ArrayList<Task> todo, ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks) throws IOException {
		boolean isLabelChanged = false;
		for (int i = 1; i < variableArray.length; i++) {
			if (variableArray[i] != null) {
				switch (i) {
				case 1:
					isLabelChanged = changeLabelName(variableArray[i], taskLabels, labelPosition, todo, deadlines,
							events, archivedTasks);
					break;
				case 2:
					isLabelChanged = changeLabelColour(variableArray[i], taskLabels, labelPosition, todo, deadlines,
							events, archivedTasks);
					break;
				}
			}
		}
		return isLabelChanged;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private boolean isTaskLabelExist(String newName, ArrayList<TaskLabel> taskLabels) {
		for (TaskLabel aLabel : taskLabels) {
			if (aLabel.getLabelName().equals(newName)) {
				return true;
			}
		}
		return false;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private boolean changeLabelName(String newName, ArrayList<TaskLabel> taskLabels, int labelPosition,
			ArrayList<Task> todo, ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks) throws IOException {
		for (int i = 0; i < taskLabels.size(); i++) {
			if (taskLabels.get(i).getLabelId() == labelPosition) {
				if (!isTaskLabelExist(newName, taskLabels)) {
					taskLabels.get(i).setLabelName(newName);
				}
			}
		}
		changeMasterListLabels(newName, labelPosition, todo, deadlines, events, archivedTasks, taskLabels, "name");
		return true;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private boolean changeLabelColour(String newColour, ArrayList<TaskLabel> taskLabels, int labelPosition,
			ArrayList<Task> todo, ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks) throws IOException {
		for (int i = 0; i < taskLabels.size(); i++) {
			if (taskLabels.get(i).getLabelId() == labelPosition) {
				taskLabels.get(i).setColourId(colourToIDMap.get(newColour));
			}
		}
		changeMasterListLabels(newColour, labelPosition, todo, deadlines, events, archivedTasks, taskLabels, "colour");
		return true;
	}

```
###### \src\org\jimple\planner\logic\LogicLabel.java
``` java
	private void changeMasterListLabels(String newString, int labelPosition, ArrayList<Task> todo,
			ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks, ArrayList<TaskLabel> taskLabels, String type)
					throws IOException {
		for (int i = 0; i < todo.size(); i++) {
			if (todo.get(i).getTaskLabel().getLabelId() == labelPosition) {
				if (!isTaskLabelExist(newString, taskLabels)) {
					if (type.equals("name")) {
						todo.get(i).getTaskLabel().setLabelName(newString);
					} else if (type.equals("colour")) {
						todo.get(i).getTaskLabel().setColourId(colourToIDMap.get(newString));
					}
				} else {
					todo.get(i).setTaskLabel(checkNewTaskLabel(newString, taskLabels));
				}
			}
		}
		for (int i = 0; i < deadlines.size(); i++) {
			if (deadlines.get(i).getTaskLabel().getLabelId() == labelPosition) {
				if (!isTaskLabelExist(newString, taskLabels)) {
					if (type.equals("name")) {
						deadlines.get(i).getTaskLabel().setLabelName(newString);
					} else if (type.equals("colour")) {
						deadlines.get(i).getTaskLabel().setColourId(colourToIDMap.get(newString));
					}
				} else {
					deadlines.get(i).setTaskLabel(checkNewTaskLabel(newString, taskLabels));
				}
			}
		}
		for (int i = 0; i < events.size(); i++) {
			if (events.get(i).getTaskLabel().getLabelId() == labelPosition) {
				if (!isTaskLabelExist(newString, taskLabels)) {
					if (type.equals("name")) {
						events.get(i).getTaskLabel().setLabelName(newString);
					} else if (type.equals("colour")) {
						events.get(i).getTaskLabel().setColourId(colourToIDMap.get(newString));
					}
				} else {
					events.get(i).setTaskLabel(checkNewTaskLabel(newString, taskLabels));
				}
			}
		}
		for (int i = 0; i < archivedTasks.size(); i++) {
			if (archivedTasks.get(i).getTaskLabel().getLabelId() == labelPosition) {
				if (!isTaskLabelExist(newString, taskLabels)) {
					if (type.equals("name")) {
						archivedTasks.get(i).getTaskLabel().setLabelName(newString);
					} else if (type.equals("colour")) {
						archivedTasks.get(i).getTaskLabel().setColourId(colourToIDMap.get(newString));
					}
				} else {
					archivedTasks.get(i).setTaskLabel(checkNewTaskLabel(newString, taskLabels));
				}
			}
		}
	}

```
###### \src\org\jimple\planner\logic\LogicMasterListModification.java
``` java
public interface LogicMasterListModification {
	
```
###### \src\org\jimple\planner\logic\LogicMasterListModification.java
``` java
	public default void allocateCorrectTimeArray(Task newTask, ArrayList<Task> todo, ArrayList<Task> deadlines,
			ArrayList<Task> events) throws IOException {
		// check if null
		if (newTask.getType().compareTo(Constants.TYPE_TODO) == 0) {
			todo.add(newTask);
		}
		// check if whole day task
		else if (newTask.getType().compareTo(Constants.TYPE_DEADLINE) == 0) {
			deadlines.add(newTask);
		} else if (newTask.getType().compareTo(Constants.TYPE_EVENT) == 0) {
			events.add(newTask);
		}
	}

```
###### \src\org\jimple\planner\logic\LogicMasterListModification.java
``` java
	public default void packageForSavingMasterLists(StorageInterface store, ArrayList<Task> todo, ArrayList<Task> deadlines,
			ArrayList<Task> events, ArrayList<Task> archivedTasks) throws IOException {
		ArrayList<ArrayList<Task>> allTasksArray = new ArrayList<ArrayList<Task>>();
		allTasksArray.add(todo);
		allTasksArray.add(deadlines);
		allTasksArray.add(events);
		allTasksArray.add(archivedTasks);
		store.isSavedTasks(allTasksArray);
	}

```
###### \src\org\jimple\planner\logic\LogicMasterListModification.java
``` java
	public default void packageForSavingLabelLists(StorageInterface store, ArrayList<TaskLabel> taskLabels) {
		store.isSavedLabels(taskLabels);
	}
	
```
###### \src\org\jimple\planner\logic\LogicMasterListModification.java
``` java
	public default void assignTaskIds(ArrayList<ArrayList<Task>> allTasks, HashMap<Integer, Boolean> idHash)	{
		for (int i=0;i<allTasks.size();i++)	{
			for (Task aTask : allTasks.get(i))	{
				LogicTaskModification.assignOneTaskId(aTask, idHash);
			}
		}
	}

```
###### \src\org\jimple\planner\logic\LogicMasterListModification.java
``` java
	public default void checkOverCurrentTime(ArrayList<Task> deadlines, ArrayList<Task> events) {
		for (Task aTask : deadlines) {
			if (aTask.getFromTime() != null) {
				if (aTask.getFromTime().compareTo(LocalDateTime.now()) < 0) {
					aTask.setIsOverDue(true);
				} else 	{
					aTask.setIsOverDue(false);
				}
			}
		}
		for (Task aTask : events) {
			if (aTask.getFromTime() != null) {
				if (aTask.getToTime().compareTo(LocalDateTime.now()) < 0) {
					aTask.setIsOverDue(true);
				} else	{
					aTask.setIsOverDue(false);
				}
			}
		}
	}

```
###### \src\org\jimple\planner\logic\LogicMasterListModification.java
``` java
	public default ArrayList<Task> getDividedTasks(ArrayList<Task> events) {
		ArrayList<Task> dividedTasks = new ArrayList<Task>();
		for (Task anEvent : events) {
			Task duplicateEvent = new Task(anEvent);
			while (!duplicateEvent.getFromTime().toLocalDate().equals(duplicateEvent.getToTime().toLocalDate())) {
				Task aNewTask = LogicTaskModification.divideMultipleDays(duplicateEvent);
				dividedTasks.add(aNewTask);
			}
			dividedTasks.add(duplicateEvent);
		}
		Task.sortTasksByTime(dividedTasks);
		return dividedTasks;
	}
}
```
###### \src\org\jimple\planner\logic\LogicPreviousTask.java
``` java
public class LogicPreviousTask {
	private Task previousTask;
	private String previousCommand;
	
```
###### \src\org\jimple\planner\logic\LogicPreviousTask.java
``` java
	public LogicPreviousTask(String previousCommand, Task previousTask) {
		this.previousCommand = previousCommand;
		this.previousTask = previousTask;
	}

```
###### \src\org\jimple\planner\logic\LogicPreviousTask.java
``` java
	public Task getPreviousTask() {
		return previousTask;
	}

```
###### \src\org\jimple\planner\logic\LogicPreviousTask.java
``` java
	public void setPreviousTask(Task previousTask) {
		this.previousTask = previousTask;
	}

```
###### \src\org\jimple\planner\logic\LogicPreviousTask.java
``` java
	public String getPreviousCommand() {
		return previousCommand;
	}

```
###### \src\org\jimple\planner\logic\LogicPreviousTask.java
``` java
	public void setPreviousCommand(String previousCommand) {
		this.previousCommand = previousCommand;
	}
}
```
###### \src\org\jimple\planner\logic\LogicSearch.java
``` java
public class LogicSearch {
	protected static String mostRecentlySearchedWord = new String("");
	
```
###### \src\org\jimple\planner\logic\LogicSearch.java
``` java
	private boolean isContainSearchedWord(String sourceString, String searchedPhrase) {
		String[] dividedSearchWords = searchedPhrase.split(" ");
		String[] dividedSourceWords = sourceString.split(" ");
		
		if (dividedSearchWords.length == 0) {
			return false;
		}
		for (int i = 0; i < dividedSearchWords.length; i++) {
			for (int j=0; j< dividedSourceWords.length; j++)	{
				if (dividedSourceWords[j].toLowerCase().equals(dividedSearchWords[i].toLowerCase()))	{
					return true;
				}
			}
		}
		return false;
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
public interface LogicTaskModification {
	
```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public default Task doEdit(String[] variableArray, Task aTask, ArrayList<TaskLabel> taskLabels) {
		Task editedTask = new Task(aTask);
		for (int i = 1; i < variableArray.length; i++) {
			switch (i) {
			case 1:
				if (variableArray[i] != null) {
					editedTask.setTitle(variableArray[i]);
				}
				break;
			case 2:
				if (variableArray[i] != null) {
					editedTask.setDescription(variableArray[i]);
				}
				break;
			case 3:
				if (variableArray[i] != null) {
					editedTask.setFromDate(variableArray[i]);
				}
				break;
			case 4:
				if (variableArray[i] != null) {
					editedTask.setToDate(variableArray[i]);
				} else if (variableArray[i] == null && variableArray[i - 1] != null) {
					editedTask.setToDate(null);
				}
				break;
			case 5:
				if (variableArray[i] != null) {
					TaskLabel label = checkNewTaskLabel(variableArray[i], taskLabels);
					editedTask.setTaskLabel(label);
				}
				break;
			default:
				break;
			}
		}
		return editedTask;
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public default void checkIfConflictedTaskExistInList(ArrayList<Task> list, Task removedTask) {
		for (int j = 0; j < list.size(); j++) {
			for (int k = 0; k < list.get(j).getConflictedTasks().size(); k++) {
				if (list.get(j).getConflictedTasks().get(k).getTaskId() == removedTask.getTaskId()) {
					list.get(j).getConflictedTasks().remove(k);
				}
			}
		}
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public default TaskLabel checkNewTaskLabel(String name, ArrayList<TaskLabel> taskLabels) {
		if (!taskLabels.isEmpty()) {
			for (TaskLabel aLabel : taskLabels) {
				if (aLabel.getLabelName().equals(name)) {
					return TaskLabel.createDuplicateTaskLabel(aLabel);
				} else if (name.equals("DEFAULT")) {
					return TaskLabel.createDefaultLabel();
				}
			}
		}
		TaskLabel newLabel = TaskLabel.createNewLabel(name);
		taskLabels.add(newLabel);
		return newLabel;
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public default boolean isFromAndToTimeCorrect(Task task) {
		if (task.getFromTime() == null && task.getToTime() == null) {
			return true;
		} else if (task.getFromTime() != null && task.getToTime() == null) {
			return true;
		} else if (task.getFromTime().compareTo(task.getToTime()) < 0) {
			return true;
		}
		return false;
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public default LogicPreviousTask setNewPreviousTask(String command, Task previousTask) {
		LogicPreviousTask aPreviousTask = new LogicPreviousTask(command, previousTask);
		return aPreviousTask;
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public default void checkOverCacheLimit(LinkedList<LogicPreviousTask> undoTasks) {
		while (undoTasks.size() > Constants.DELETE_CACHE_LIMIT) {
			undoTasks.removeFirst();
		}
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public static Task divideMultipleDays(Task aTask) {
		Task newTask = new Task(aTask);
		newTask.setToDate(newTask.getFromTime().toLocalDate().toString() + "T23:59");
		aTask.setFromDate(aTask.getFromTime().toLocalDate().plusDays(1).toString() + "T00:00");
		return newTask;
	}

```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public static boolean isFromDateEqualToDate(Task aTask) {
		return aTask.getFromTime().toLocalDate().equals(aTask.getToTime().toLocalDate());
	}
	
```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public static void assignOneTaskId(Task newTask, HashMap<Integer, Boolean> idHash) {
		for (int i = 0; i < Constants.MAX_ID; i++) {
			if (idHash.get(i+1).booleanValue() == false) {
				newTask.setTaskId(i+1);
				idHash.put(i+1, true);
				break;
			}
		}
	}
	
```
###### \src\org\jimple\planner\logic\LogicTaskModification.java
``` java
	public default void removeTaskId(Task removedTask, HashMap<Integer, Boolean> idHash)	{
		idHash.put(removedTask.getTaskId(), false);
	}
}
```
###### \src\org\jimple\planner\logic\LogicUndo.java
``` java
public class LogicUndo implements LogicTaskModification, LogicMasterListModification {
	
```
###### \src\org\jimple\planner\logic\LogicUndo.java
``` java
	protected String undoPreviousChange(LinkedList<LogicPreviousTask> undoTasks, ArrayList<Task> todo,
			ArrayList<Task> deadlines, ArrayList<Task> events, ArrayList<Task> archivedTasks,
			ArrayList<Task> tempHistory, ArrayList<TaskLabel> taskLabels, HashMap<Integer, Boolean> idHash)
					throws IOException {
		String[] variableArray = new String[1];
		if (undoTasks.size() == 0) {
			return Constants.UNDO_FEEDBACK_ERROR;
		}
		checkOverCacheLimit(undoTasks);
		LogicPreviousTask aTask = undoTasks.removeLast();
		switch (aTask.getPreviousCommand()) {
		case Constants.STRING_ADD:
			variableArray[0] = Integer.toString(aTask.getPreviousTask().getTaskId());
			deletionForUndo(variableArray, todo, deadlines, events, archivedTasks, idHash);
			break;
		case Constants.STRING_DELETE:
			if (aTask.getPreviousTask().getIsDone() == false) {
				allocateCorrectTimeArray(aTask.getPreviousTask(), todo, deadlines, events);
			} else {
				archivedTasks.add(aTask.getPreviousTask());
			}
			break;
		case Constants.STRING_EDIT:
			variableArray[0] = Integer.toString(aTask.getPreviousTask().getTaskId());
			deletionForUndo(variableArray, todo, deadlines, events, archivedTasks, idHash);
			LogicTaskModification.assignOneTaskId(aTask.getPreviousTask(), idHash);
			allocateCorrectTimeArray(tempHistory.remove(tempHistory.size() - 1), todo, deadlines, events);
			break;
		case Constants.STRING_DONE:
			variableArray[0] = Integer.toString(aTask.getPreviousTask().getTaskId());
			deletionForUndo(variableArray, todo, deadlines, events, archivedTasks, idHash);
			LogicTaskModification.assignOneTaskId(aTask.getPreviousTask(), idHash);
			aTask.getPreviousTask().setIsDone(false);
			allocateCorrectTimeArray(aTask.getPreviousTask(), todo, deadlines, events);
			break;
		case Constants.STRING_RETURN:
			variableArray[0] = Integer.toString(aTask.getPreviousTask().getTaskId());
			deletionForUndo(variableArray, todo, deadlines, events, archivedTasks, idHash);
			LogicTaskModification.assignOneTaskId(aTask.getPreviousTask(), idHash);
			aTask.getPreviousTask().setIsDone(true);
			archivedTasks.add(aTask.getPreviousTask());
			break;
		}
		return "task \"" + aTask.getPreviousTask().getTitle() + "\"" + Constants.UNDO_FEEDBACK;
	}

```
###### \src\org\jimple\planner\logic\LogicUndo.java
``` java
	private void deletionForUndo(String[] variableArray, ArrayList<Task> todo, ArrayList<Task> deadlines,
			ArrayList<Task> events, ArrayList<Task> archivedTasks, HashMap<Integer, Boolean> idHash) {
		boolean isFloatDeleted = false;
		boolean isDeadlineDeleted = false;
		boolean isEventDeleted = false;

		isFloatDeleted = findTaskToDeleteForUndo(variableArray, todo, idHash);
		if (!isFloatDeleted) {
			isDeadlineDeleted = findTaskToDeleteForUndo(variableArray, deadlines, idHash);
		}
		if (!isFloatDeleted && !isDeadlineDeleted) {
			isEventDeleted = findTaskToDeleteForUndo(variableArray, events, idHash);
		}
		if (!isFloatDeleted && !isDeadlineDeleted && !isEventDeleted) {
			findTaskToDeleteForUndo(variableArray, archivedTasks, idHash);
		}
	}

```
###### \src\org\jimple\planner\logic\LogicUndo.java
``` java
	private boolean findTaskToDeleteForUndo(String[] variableArray, ArrayList<Task> list,
			HashMap<Integer, Boolean> idHash) {
		for (int i = 0; i < list.size(); i++) {
			if (Integer.parseInt(variableArray[0]) == list.get(i).getTaskId()) {
				Task removedTask = list.remove(i);
				removeTaskId(removedTask, idHash);
				return true;
			}
		}
		return false;
	}

```
###### \src\org\jimple\planner\observers\myObserver.java
``` java
public abstract class myObserver {
	protected Logic logic;
	public abstract void update();
	public abstract void update(String[] displayType);
}
```
###### \src\org\jimple\planner\task\Formatter.java
``` java
public class Formatter {
	public ListOfMonths listOfMonths;

	public Formatter() {
		listOfMonths = new ListOfMonths();
	}

	public String formatPrettyDate(LocalDateTime dateTime) {
		String prettyDate = new String("");
		assert dateTime != null;
		prettyDate += dateTime.getDayOfMonth();
		prettyDate += "/";
		prettyDate += dateTime.getMonthValue();
		prettyDate += "/";
		prettyDate += dateTime.getYear();

		return prettyDate;
	}
	
	public String formatPrettyTime(LocalDateTime dateTime)	{
		String prettyTime = new String("");
		prettyTime += dateTime.getHour();
		prettyTime += ":";
		if (dateTime.getMinute() < 10) {
			prettyTime += "0";
		}
		prettyTime += dateTime.getMinute();
		return prettyTime;
	}
	
	@Deprecated
	public String newFormatDateTime(Date date) {
		String formattedDateTime = new String("");
		formattedDateTime += (date.getYear() + 1900);
		formattedDateTime += newFormatMonth(date.getMonth());
		formattedDateTime += newFormatDay(date.getDate());
		formattedDateTime += newFormatTime(date);
		return formattedDateTime;
	}
	
	@Deprecated
	private String newFormatTime(Date time) {
		String formattedHoursMinutes = new String("");
		formattedHoursMinutes += formatTime(time.getHours());
		formattedHoursMinutes += ":";
		formattedHoursMinutes += formatTime(time.getMinutes());
		return formattedHoursMinutes;
	}
	
	@Deprecated
	private String formatTime(int time) {
		String formattedTime = new String("");
		if (isLessThanTen(time)) {
			formattedTime += "0";
		}
		formattedTime += time;
		return formattedTime;
	}
	
	@Deprecated
	private String newFormatDay(int day) {
		String formattedDay = new String("");
		if (isLessThanTen(day)) {
			formattedDay += "0";
		}
		formattedDay += day;
		formattedDay += "T";

		return formattedDay;
	}
	
	@Deprecated
	private String newFormatMonth(int month) {
		String formattedMonth = new String("");
		formattedMonth += "-";
		formattedMonth += listOfMonths.newMonthDigit(month);
		formattedMonth += "-";
		return formattedMonth;
	}
	
	@Deprecated
	public String formatTaskForDisplay(ArrayList<Task> list) {
		String formattedTasks = new String("");
		for (Task aTask : list) {
			formattedTasks += aTask.getTitle().concat("\n");
		}
		return formattedTasks;
	}
	
	@Deprecated
	public String formatSearchString(ArrayList<String> searchResults) {
		String formattedResult = new String("");
		for (String result : searchResults) {
			formattedResult += result;
			formattedResult += "\n";
		}
		return formattedResult;
	}
	
	@Deprecated
	public String formatDateTime(String unformattedDate) {
		if (unformattedDate != null) {
			String[] dividedDates = unformattedDate.split(" ");
			String formattedDateTime = Integer.toString(LocalDateTime.now().getYear());
			for (String dateTime : dividedDates) {
				if (checkYear(dateTime) != null) {
					formattedDateTime = checkYear(dateTime);
					break;
				}
			}
			formattedDateTime += checkMonth(
					LocalDateTime.now().getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH));
			for (String dateTime : dividedDates) {
				if (!checkMonth(dateTime).equals("")) {
					formattedDateTime = formattedDateTime.substring(0, formattedDateTime.length() - 4)
							.concat(checkMonth(dateTime));
					break;
				}
			}
			formattedDateTime += checkDay(Integer.toString(LocalDateTime.now().getDayOfMonth()));
			for (String dateTime : dividedDates) {
				if (!checkDay(dateTime).equals("")) {
					formattedDateTime = formattedDateTime.substring(0, formattedDateTime.length() - 3)
							.concat(checkDay(dateTime));
					break;
				}
			}
			for (String dateTime : dividedDates) {
				if (!checkTime(dateTime).equals("")) {
					formattedDateTime += checkTime(dateTime);
					break;
				}
			}
			return formattedDateTime;
		}
		return unformattedDate;
	}
	
	@Deprecated
	private String checkYear(String dateTime) {
		if (isYear(dateTime)) {
			return dateTime;
		}
		return null;
	}
	
	@Deprecated
	private boolean isYear(String dateTime) {
		try {
			if (Integer.parseInt(dateTime) - 1000 > 0) {
				return true;
			}
		} catch (NumberFormatException e) {
			return false;
		}
		return false;
	}
	
	@Deprecated
	public String checkMonth(String dateTime) {
		String formattedMonth = new String("");
		if (listOfMonths.contain(dateTime)) {
			formattedMonth += "-";
			formattedMonth += listOfMonths.monthDigit(dateTime);
			formattedMonth += "-";
		}
		return formattedMonth;
	}
	
	@Deprecated
	private String checkDay(String dateTime) {
		String formattedDay = new String("");
		if (isDay(dateTime)) {
			if (isLessThanTen(Integer.parseInt(dateTime))) {
				formattedDay += "0";
			}
			formattedDay += dateTime;
			formattedDay += "T";
		}
		return formattedDay;
	}
	
	@Deprecated
	private boolean isLessThanTen(int dateTime) {
		if (dateTime < 10) {
			return true;
		}
		return false;
	}
	
	@Deprecated
	private boolean isDay(String dateTime) {
		try {
			if (Integer.parseInt(dateTime) - 1000 < 0) {
				return true;
			}
		} catch (NumberFormatException e) {
			return false;
		}
		return false;
	}
	
	@Deprecated
	public String checkTime(String dateTime) {
		String formattedHoursMinutes = new String("");
		if (dateTime.contains("am")) {
			dateTime = dateTime.substring(0, dateTime.length() - 2);
			String[] time = dateTime.split("\\.");
			formattedHoursMinutes += formatHourAM(time);
			formattedHoursMinutes += ":";
			formattedHoursMinutes += formatMinutes(time);
		} else if (dateTime.contains("pm")) {
			dateTime = dateTime.substring(0, dateTime.length() - 2);
			String[] time = dateTime.split("\\.");
			formattedHoursMinutes += formatHourPM(time);
			formattedHoursMinutes += ":";
			formattedHoursMinutes += formatMinutes(time);
		}
		return formattedHoursMinutes;
	}
	
	@Deprecated
	private String formatHourPM(String[] time) {
		String formattedHour = new String("");
		if (time[0].equals("12")) {
			formattedHour = time[0];
		} else {
			formattedHour += Integer.parseInt(time[0]) + 12;
		}
		return formattedHour;
	}
	
	@Deprecated
	private String formatHourAM(String[] time) {
		String formattedHour = new String("");
		if (isLessThanTen(Integer.parseInt(time[0]))) {
			formattedHour += "0";
		}
		if (time[0].equals("12")) {
			formattedHour += "00";
		} else {
			formattedHour += time[0];
		}
		return formattedHour;
	}
	
	@Deprecated
	private String formatMinutes(String[] time) {
		String formattedMinutes = new String("");
		if (time.length > 1) {
			if (isLessThanTen(Integer.parseInt(time[1]))) {
				formattedMinutes += "0";
			}
			formattedMinutes += time[1];
		} else {
			formattedMinutes += "00";
		}
		return formattedMinutes;
	}

	public String testCheckYear(String dateTime) {
		return checkYear(dateTime);
	}

	public String testCheckMonth(String dateTime) {
		return checkMonth(dateTime);
	}

	public String testCheckDay(String dateTime) {
		return checkDay(dateTime);
	}

	public String testCheckTime(String dateTime) {
		return checkTime(dateTime);
	}

	public String testFormatTime(String unformattedDate) {
		return formatDateTime(unformattedDate);
	}

}
```
###### \src\org\jimple\planner\task\Task.java
``` java
	public ArrayList<Task> getConflictedTasks()	{
		return conflictedTasks;
	}
```
###### \src\org\jimple\planner\test\logic\LogicAddIntegrationTest.java
``` java
/**
 * All test cases in integration tests are time sensitive.
 * Planner.jim file must be empty before starting test cases
 * @author Brandon
 *
 */
public class LogicAddIntegrationTest {
	Logic testLogic = new Logic();
	
	/**
	 * Test cases are time sensitive. 
	 * task 1: pass only if after 1pm
	 * task 2: pass only if before 9 december 2016
	 * task 4: pass only if after 12am
	 * task 5: pass only if after 11am
	 * @throws IOException
	 */
	@Test
	public void ShouldTestFromAndToTime() throws IOException	{
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 1 FROM 1pm TO 3pm");
		assertEquals("task 1", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate().plusDays(1) + "T13:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals(LocalDateTime.now().toLocalDate().plusDays(1) + "T15:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 2 FROM 9 december 1300 TO 1400");
		assertEquals("task 2", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals("2016-12-09T13:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals("2016-12-09T14:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 3 FROM today TO tomorrow");
		assertEquals("task 3", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate() + "T00:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals(LocalDateTime.now().toLocalDate().plusDays(1) + "T23:59", testLogic.getEventsDividedList().get(1).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 4 FROM 12am TO 7pm");
		assertEquals("task 4", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate().plusDays(1) + "T00:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals(LocalDateTime.now().toLocalDate().plusDays(1) + "T19:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 5 FROM 1100 TO 1800");
		assertEquals("task 5", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate().plusDays(1) + "T11:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals(LocalDateTime.now().toLocalDate().plusDays(1) + "T18:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
	}
	
	/**
	 * test cases are time sensitive
	 * task 9: pass only if date is adjusted to the coming monday of the week
	 * @throws IOException
	 */
	@Test
	public void ShouldTestByTime() throws IOException	{
		testLogic.getDeadlinesList().clear();
		
		testLogic.execute("ADD task 9 BY monday");
		assertEquals("task 9", testLogic.getDeadlinesList().get(0).getTitle());
		assertEquals("2016-04-11T23:59", testLogic.getDeadlinesList().get(0).getFromTimeString());
		testLogic.getDeadlinesList().clear();
		
		testLogic.execute("ADD task 10 BY today");
		assertEquals("task 10", testLogic.getDeadlinesList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate() + "T23:59", testLogic.getDeadlinesList().get(0).getFromTimeString());
		testLogic.getDeadlinesList().clear();
		
		testLogic.execute("ADD task 11 BY tomorrow");
		assertEquals("task 11", testLogic.getDeadlinesList().get(0).getTitle());
		assertEquals(LocalDateTime.now().plusDays(1).toLocalDate() + "T23:59", testLogic.getDeadlinesList().get(0).getFromTimeString());
		testLogic.getDeadlinesList().clear();
	}
	
	/**
	 * test cases are time sensitive
	 * task 6: pass only if time is before 10 dec 2016
	 * task 7: pass only if time is before 11 dec 2016 3pm
	 * @throws IOException
	 */
	@Test
	public void ShouldTestOnTime() throws IOException	{
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 6 ON 10 dec");
		assertEquals("task 6", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals("2016-12-10T00:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals("2016-12-10T23:59", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 7 ON 11 dec 3pm");
		assertEquals("task 7", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals("2016-12-11T15:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals("2016-12-11T23:59", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
	}
	
	/**
	 * test cases are time sensitive
	 * task 12: pass only if time now is before 10pm
	 * task 13: pass only if time now is before 13 dec 2016
	 * @throws IOException
	 */
	@Test
	public void ShouldTestAtTime() throws IOException	{
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 12 AT 10pm");
		assertEquals("task 12", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate() + "T22:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals(LocalDateTime.now().toLocalDate() + "T23:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();

		testLogic.execute("ADD task 13 AT 13 dec 6pm");
		assertEquals("task 13", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals("2016-12-13T18:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals("2016-12-13T19:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
	}
}
```
###### \src\org\jimple\planner\test\logic\LogicEditIntegrationTest.java
``` java
/**
 * All test cases in integration tests are time sensitive.
 * Planner.jim file must be empty before starting test cases
 * @author Brandon
 *
 */
public class LogicEditIntegrationTest {
	Logic testLogic = new Logic();
	
	@Test
	public void ShouldTestEditFromToTime() throws IOException	{
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 1 FROM 1pm TO 3pm");
		testLogic.execute("EDIT 2 TIME FROM 1pm TO 2pm");
		assertEquals("task 1", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals("2016-04-11T13:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals("2016-04-11T14:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
		testLogic.execute("ADD task 2 FROM 1pm TO 3pm");
		testLogic.execute("EDIT 3 TIME FROM 1400 TO 1500");
		assertEquals("task 2", testLogic.getEventsDividedList().get(0).getTitle());
		assertEquals("2016-04-11T14:00", testLogic.getEventsDividedList().get(0).getFromTimeString());
		assertEquals("2016-04-11T15:00", testLogic.getEventsDividedList().get(0).getToTimeString());
		testLogic.getEventsDividedList().clear();
		testLogic.getEventsList().clear();
		
	}
	
	/**
	 * test cases are time sensitive
	 * task 3: pass only if time is before 3pm
	 * task 4: pass only if time is before 1pm
	 * @throws IOException
	 */
	@Test
	public void ShouldTestEditByTime() throws IOException	{
		testLogic.getDeadlinesList().clear();
		
		testLogic.execute("ADD task 3 BY 3pm");
		testLogic.execute("EDIT 1 TIME BY 4pm");
		assertEquals("task 3", testLogic.getDeadlinesList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate() + "T16:00", testLogic.getDeadlinesList().get(0).getFromTimeString());
		testLogic.getDeadlinesList().clear();
		
		testLogic.execute("ADD task 4 BY 1pm");
		testLogic.execute("EDIT 2 TIME BY 1700 ");
		assertEquals("task 4", testLogic.getDeadlinesList().get(0).getTitle());
		assertEquals(LocalDateTime.now().toLocalDate() + "T17:00", testLogic.getDeadlinesList().get(0).getFromTimeString());
		testLogic.getDeadlinesList().clear();
	}
}
```
###### \src\org\jimple\planner\test\logic\LogicTest.java
``` java
public class LogicTest {
	Formatter testformatter = new Formatter();
	Logic testLogic = new Logic();
	StorageInterface testStore = new Storage();
	LogicAdd testAdder = new LogicAdd();
	LogicEdit testEditer = new LogicEdit();
	LogicDelete testDeleter = new LogicDelete();
	LogicSearch testSearcher = new LogicSearch();
	LogicDirectory testDirecter = new LogicDirectory();
	LogicUndo testUndoer = new LogicUndo();
	LogicLabel testLabeler = new LogicLabel();
	LogicArchive testArchiver = new LogicArchive();
	ArrayList<Task> floating = new ArrayList<Task>();
	ArrayList<Task> deadlines = new ArrayList<Task>();
	ArrayList<Task> events = new ArrayList<Task>();
	ArrayList<Task> tempHistory = new ArrayList<Task>();
	ArrayList<Task>	archivedTasks = new ArrayList<Task>();
	ArrayList<TaskLabel> taskLabels = new ArrayList<TaskLabel>();
	LinkedList<LogicPreviousTask> undoTasks = new LinkedList<LogicPreviousTask>();
	HashMap<Integer, Boolean> idHash = new HashMap<Integer, Boolean>();


	private void initializeThreeArrays() {
		Task todo1 = new Task("a test only one");
		Task deadlines1 = new Task("a test only two");
		Task events1 = new Task("a test only three");
		Task events2 = new Task("a test four");
		todo1.setType("floating");
		todo1.setTaskId(1);
		deadlines1.setType("deadline");
		deadlines1.setTaskId(2);
		deadlines1.setFromDate("2016-03-30T16:00");
		events1.setType("event");
		events1.setTaskId(3);
		events1.setFromDate("2016-03-25T09:00");
		events1.setToDate("2016-03-27T17:00");
		events2.setType("event");
		events2.setTaskId(4);
		events2.setFromDate("2016-03-28T07:00");
		events2.setToDate("2016-03-30T11:00");
		floating.add(todo1);
		deadlines.add(deadlines1);
		events.add(events1);
		events.add(events2);
	}
	
	private void initializeIDMap() {
		for (int i = 0; i < Constants.MAX_ID; i++) {
			idHash.put(i + 1, false);
		}
	}
	
	@Test
	public void ShouldReturnPrettyDate() {
		LocalDateTime testDate = null;
		testDate = LocalDateTime.parse("2016-01-12T15:30");
		assertEquals("12/1/2016", testformatter.formatPrettyDate(testDate));
	}
	
	/**
	 * EP: 2 cases
	 * 1. task is found and returned to list
	 * 2. task is not found and not returned to list
	 */
	@Test
	public void ShouldReturnUnArchivedTasks() throws IOException	{
		initializeThreeArrays();
		String[] parsedInput = {"1"};
		testArchiver.testMarkTaskAsDone(parsedInput, undoTasks, tempHistory, floating, deadlines, events, archivedTasks, taskLabels);
		assertEquals("task 1 has returned to your list", testArchiver.testMarkTaskAsUndone(parsedInput, undoTasks, tempHistory, floating, deadlines, events, archivedTasks, taskLabels));
		assertEquals("a test only one", floating.get(0).getTitle());
		parsedInput[0] = "5";
		assertEquals("task 5 could not be returned to your list", testArchiver.testMarkTaskAsUndone(parsedInput, undoTasks, tempHistory, floating, deadlines, events, archivedTasks, taskLabels));
	}
	
	/**
	 * EP: 2 cases
	 * 1. if task is found and archived 
	 * 2  task does not exist
	 */
	@Test
	public void ShouldReturnArchivedTasks() throws IOException	{
		initializeThreeArrays();
		String[] parsedInput = {"1"};
		assertEquals("task 1 is now archived", testArchiver.testMarkTaskAsDone(parsedInput, undoTasks, tempHistory, floating, deadlines, events, archivedTasks, taskLabels));
		assertTrue(floating.isEmpty());
		assertEquals("a test only one", archivedTasks.get(0).getTitle());
		parsedInput[0] = "5";
		assertEquals("task 5 does not exist and could not be archived", testArchiver.testMarkTaskAsDone(parsedInput, undoTasks, tempHistory, floating, deadlines, events, archivedTasks, taskLabels));
	}
	
	/**
	 * EP: 2 cases
	 * 1. label is deleted from tasklabels array list and from all current tasks
	 * 2. label cannot be deleted 
	 */
	@Test
	public void ShouldRetunDeletedLabel() {
	}
	
	/**
	 * EP: 3 test cases
	 * 1. change label color
	 * 2. change label name
	 * 3. no label to change
	 * 
	 * @throws IOException 
	 */
	@Test
	public void ShouldReturnChangedLabel() throws IOException	{
		taskLabels.add(TaskLabel.createNewLabel("food"));
		taskLabels.add(TaskLabel.createNewLabel("work"));
		String[] variableArray1 = {"food", null, "red"};
		String[] variableArray2 = {"work", "exercise", null};
		String[] variableArray3 = {"stuff", "wrong", "wrong"};
		assertEquals("food label changed", testLabeler.testChangeLabel(variableArray1, taskLabels, floating, deadlines, events, archivedTasks));
		assertEquals("work label changed", testLabeler.testChangeLabel(variableArray2, taskLabels, floating, deadlines, events, archivedTasks));
		assertEquals("label could not be changed", testLabeler.testChangeLabel(variableArray3, taskLabels, floating, deadlines, events, archivedTasks));
		
		taskLabels.clear();
	}
	
	/**
	 * test case checks if dates are divided when spanning multiple days
	 */
	@Test
	public void ShouldReturnMultipleTaskOfDifferentDays()	{
		Task aTask = new Task("test Task");
		aTask.setFromDate("2016-04-10T10:00");
		aTask.setToDate("2016-04-12T15:00");
		ArrayList<Task>	modifiedTasks = new ArrayList<Task>();
		while (!LogicTaskModification.isFromDateEqualToDate(aTask))	{
			Task dividedTask = LogicTaskModification.divideMultipleDays(aTask);
			modifiedTasks.add(dividedTask);
		}
		modifiedTasks.add(aTask);
		assertEquals("2016-04-10T10:00", modifiedTasks.get(0).getFromTimeString());
		assertEquals("2016-04-10T23:59", modifiedTasks.get(0).getToTimeString());
		assertEquals("2016-04-11T00:00", modifiedTasks.get(1).getFromTimeString());
		assertEquals("2016-04-11T23:59", modifiedTasks.get(1).getToTimeString());
		assertEquals("2016-04-12T00:00", modifiedTasks.get(2).getFromTimeString());
		assertEquals("2016-04-12T15:00", modifiedTasks.get(2).getToTimeString());
	}
	
	/**
	 * EP: 5 test cases 1. Empty 2. when undo is for an "add" command 3. when
	 * undo is for a "delete" command 4. when undo is for a "edit" command 5.
	 * when delete cache is >20
	 * 
	 * @throws InvalidFromAndToTimeException
	 */
	@Test
	public void ShouldReturnUndoCommand() throws IOException, InvalidFromAndToTimeException  {
		String[] variableArray1 = { "1" };
		String[] variableArray2 = { "todo", "task to be undone", null, null, null, null };
		String[] variableArray3 = { "1", "edit task to be undone", null, null, null, null };

		// test for empty
		assertEquals(Constants.UNDO_FEEDBACK_ERROR,
				testUndoer.testUndoPreviousChange(undoTasks, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, idHash));
		initializeThreeArrays();

		testDeleter.testDeleteTask(variableArray1, floating, deadlines, events, archivedTasks, undoTasks, idHash);
		assertEquals("task \"" + "a test only one" + "\"" + Constants.UNDO_FEEDBACK,
				testUndoer.testUndoPreviousChange(undoTasks, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, idHash));
		// test for add
		testAdder.testAddToTaskList(variableArray2, tempHistory, floating, deadlines, events, taskLabels, undoTasks, idHash);
		assertEquals("task \"" + "task to be undone" + "\"" + Constants.UNDO_FEEDBACK,
				testUndoer.testUndoPreviousChange(undoTasks, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, idHash));
		// test for edit
		testEditer.testEditTask(variableArray3, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, undoTasks, idHash);
		assertEquals("task \"" + "edit task to be undone" + "\"" + Constants.UNDO_FEEDBACK,
				testUndoer.testUndoPreviousChange(undoTasks, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, idHash));

		// test for overshot
		for (int i = 0; i < 22; i++) {
			LogicPreviousTask testTask = new LogicPreviousTask("floating", new Task(Integer.toString(i)));
			undoTasks.add(testTask);
		}
		assertEquals("task \"" + "21" + "\"" + Constants.UNDO_FEEDBACK,
				testUndoer.testUndoPreviousChange(undoTasks, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, idHash));
	}

	/*
	 * EP: 2 cases 1. Task is found and deleted 2. Task cannot be found and no
	 * deletion
	 */
	@Test
	public void ShouldReturnTrueAfterDeleteFromArray() throws IOException {
		String[] variableArray = { "1" };
		initializeThreeArrays();
		assertTrue("delete string", testDeleter.testFindTaskToDelete(variableArray, floating, undoTasks, idHash));
		variableArray[0] = "4";
		assertFalse("delete string", testDeleter.testFindTaskToDelete(variableArray, floating, undoTasks, idHash));
	}

	/*
	 * EP: 2 cases 1. able to find task and edit 2. unable to find task and no
	 * edit
	 */
	@Test
	public void ShouldReturnTrueAfterEditting() throws IOException, InvalidFromAndToTimeException{
		String[] variableArray = { "1", "task one", null, "2016-03-12T14:00", null, null };
		initializeThreeArrays();
		assertTrue("return true after editting", testEditer.testFindTaskToEdit(variableArray, floating, floating,
				deadlines, events, archivedTasks, tempHistory, taskLabels, undoTasks, idHash));
		variableArray[0] = "6";
		assertFalse("return true after editting", testEditer.testFindTaskToEdit(variableArray, floating, floating,
				deadlines, events, archivedTasks, tempHistory, taskLabels, undoTasks, idHash));
	}

	/*
	 * EP: 2 cases 1. able to find task and edit and store inside storage 2.
	 * unable to find task and no edit
	 */
	@Test
	public void ShouldReturnFeedbackAfterCheckThreeArrayToEdit() throws IOException, InvalidFromAndToTimeException{
		String[] variableArray = { "1", "task one", null, "2016-03-30T05:00", null, null };
		initializeThreeArrays();
		assertEquals("return same string", "task 1 edited in planner",
				testEditer.testEditTask(variableArray, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, undoTasks, idHash));
		variableArray[0] = "10";
		assertEquals("return same string", "task 10 could not be edited",
				testEditer.testEditTask(variableArray, floating, deadlines, events, archivedTasks, tempHistory, taskLabels, undoTasks, idHash));
	}

	/**
	 * EP: 5 cases 
	 * 1. add for deadlines 
	 * 2. add for events 
	 * 3. add for todo
	 * 4. add a label when does not exist
	 * 5. add a label when exist
	 * 6. add a label with "default" if null
	 * @throws InvalidFromAndToTimeException 
	 */
	@Test
	public void ShouldReturnFeedbackAfterAdding() throws IOException, InvalidFromAndToTimeException {
		initializeIDMap();
		String[] parsedInput1 = { "deadlines", "finish 2103 homework", null, "2016-03-28T13:00", null, null };
		assertEquals("task is added to file", "\"finish 2103 homework\" added to planner", testAdder
				.testAddToTaskList(parsedInput1, tempHistory, floating, deadlines, events, taskLabels, undoTasks, idHash));
		
		String[] parsedInput2 = { "events", "finish 2010 homework", null, "2016-03-29T12:00", "2016-03-30T13:00",
				null };
		assertEquals("\"finish 2010 homework\" added to planner", testAdder.testAddToTaskList(parsedInput2,
				tempHistory, floating, deadlines, events, taskLabels, undoTasks, idHash));
		
		String[] parsedInput3 = { "todo", "finish 3241 homework", null, null, null, null };
		assertEquals("\"finish 3241 homework\" added to planner", testAdder.testAddToTaskList(parsedInput3,
				tempHistory, floating, deadlines, events, taskLabels, undoTasks, idHash));
		
		String[] parsedInput4 = { "todo", "finish 3241 homework", null, null, null, "work" };
		testAdder.testAddToTaskList(parsedInput4, tempHistory, floating, deadlines, events, taskLabels, undoTasks, idHash);
		assertEquals("work", taskLabels.get(0).getLabelName());
		
		taskLabels.add(TaskLabel.createNewLabel("food"));
		String[] parsedInput5 = { "todo", "buy hotpot ingredients", null, null, null, "food" };
		testAdder.testAddToTaskList(parsedInput5, tempHistory, floating, deadlines, events, taskLabels, undoTasks, idHash);
		assertEquals("food", floating.get(2).getTaskLabel().getLabelName());
		
		String[] parsedInput6 = { "todo", "do some running", null, null, null, null };
		testAdder.testAddToTaskList(parsedInput6, tempHistory, floating, deadlines, events, taskLabels, undoTasks, idHash);
		assertEquals("default", floating.get(3).getTaskLabel().getLabelName());
	}

	/**
	 * EP: 2 cases 1. Return all tasks with titles inside name 2. Return empty
	 * list
	 */
	@Test
	public void ShoudReturnListOfTasksFromSearching() {
		String wordToBeSearched = "only";
		ArrayList<Task> list = new ArrayList<Task>();
		list.add(new Task("stuff and stuff"));
		list.add(new Task("some stuff only"));
		list.add(new Task("only stuff"));

		ArrayList<Task> searchResults = testSearcher.testgetSearchedTasks(wordToBeSearched, list);
		assertEquals("some stuff only", searchResults.get(0).getTitle());
		assertEquals("only stuff", searchResults.get(1).getTitle());
		wordToBeSearched = "thing";
		searchResults = testSearcher.testgetSearchedTasks(wordToBeSearched, list);
		assertTrue(searchResults.isEmpty());
	}

	/**
	 * Searches for strings in master arrays and returns results that are the same
	 */
	@Test
	public void ShouldReturnArrayListOfTasks() throws IOException {
		ArrayList<Task> expected = new ArrayList<Task>();
		String wordToBeSearched = "only";
		assertEquals("should be same", expected,
				testSearcher.testSearchWord(wordToBeSearched, floating, deadlines, events, archivedTasks));
		initializeThreeArrays();
		expected.add(new Task("a test only one"));
		expected.add(new Task("a test only two"));
		expected.add(new Task("a test only three"));
		ArrayList<Task> result = testSearcher.testSearchWord(wordToBeSearched, floating, deadlines, events, archivedTasks);
		assertEquals("should be the same", expected.get(0).getTitle(), result.get(0).getTitle());
		assertEquals("should be the same", expected.get(1).getTitle(), result.get(1).getTitle());
		assertEquals("should be the same", expected.get(2).getTitle(), result.get(2).getTitle());
	}

	@Test
	public void ShouldReturnTrueIfContainKeyword() {
		Task event = new Task("a test only");
		event.setDescription("good stuff");
		assertTrue("returns true", testSearcher.testIsContainKeyword(event, "good"));
		assertTrue("returns true", testSearcher.testIsContainKeyword(event, "a test only"));
		assertTrue("returns true", testSearcher.testIsContainKeyword(event, "good food"));
		assertTrue("returns true", testSearcher.testIsContainKeyword(event, "a only"));
		assertFalse("returns false", testSearcher.testIsContainKeyword(event, "wrong"));
	}

	@Test
	public void ShouldReturnCorrectFormatMessage() {
		assertEquals("return formated date", "2016-05-12T16:00", testformatter.testFormatTime("12 May 4pm"));
		assertEquals("return formated date", LocalDateTime.now().toLocalDate() + "T14:30", testformatter.testFormatTime("today 2.30pm"));
		assertEquals("return formated date", "2018-12-18T00:00", testformatter.testFormatTime("2018 12am 18 december"));
		assertEquals("return formated date", LocalDateTime.now().toLocalDate() + "T23:00", testformatter.testFormatTime("11pm"));
	}

	@Test
	public void ShouldReturnCorrectYear() {
		assertEquals("return year", null, testformatter.testCheckYear("today"));
		assertEquals("return year", "2018", testformatter.testCheckYear("2018"));
		assertEquals("return year", null, testformatter.testCheckYear("may"));
		assertEquals("return year", null, testformatter.testCheckYear("6"));
		// assertEquals("returns feedback", "taskEd")
	}

	@Test
	public void ShoudReturnCorrectMonth() {
		assertEquals("return month", "-02-", testformatter.testCheckMonth("february"));
		assertEquals("return month", "-05-", testformatter.testCheckMonth("May"));
		assertEquals("return month", "-12-", testformatter.testCheckMonth("december"));
		assertEquals("return month", "", testformatter.testCheckMonth("today"));
		assertEquals("return month", "", testformatter.testCheckMonth("10"));
		assertEquals("return month", "", testformatter.testCheckMonth("2018"));
	}

	@Test
	public void ShouldReturnCorrectDay() {
		assertEquals("return day", "10T", testformatter.testCheckDay("10"));
		assertEquals("return day", "05T", testformatter.testCheckDay("5"));
		assertEquals("return day", "", testformatter.testCheckDay("today"));
		assertEquals("return day", "", testformatter.testCheckDay("march"));
		assertEquals("return day", "", testformatter.testCheckDay("2017"));
	}

	@Test
	public void ShouldReturnCorrectTime() {
		assertEquals("return time", "00:00", testformatter.testCheckTime("12am"));
		assertEquals("return time", "09:00", testformatter.testCheckTime("9am"));
		assertEquals("return time", "12:30", testformatter.testCheckTime("12.30pm"));
		assertEquals("return time", "", testformatter.testCheckTime("today"));
		assertEquals("return time", "", testformatter.testCheckTime("2017"));
		assertEquals("return time", "", testformatter.testCheckTime("12"));
	}

}
```
###### \src\org\jimple\planner\test\logic\LogicTestSuite.java
``` java
@RunWith(Suite.class)
@SuiteClasses({ 
	LogicAddIntegrationTest.class,
	LogicEditIntegrationTest.class,
	LogicTest.class 
})

public class LogicTestSuite {

}
```
