# A0122498
###### ./src/org/jimple/planner/ui/UiComponent.java
``` java
import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class UiComponent extends Application {
	double xOffset;
	double yOffset;
	@Override
	public void start(Stage primaryStage) {
		try {
			Parent root = FXMLLoader.load(getClass().getResource("JimpleUI.fxml"));
			root.setOnMousePressed(new EventHandler<MouseEvent>() {
	            @Override
	            public void handle(MouseEvent event) {
	                xOffset = primaryStage.getX() - event.getScreenX();
	                yOffset = primaryStage.getY() - event.getScreenY();
	            }
	        });
			
			root.setOnMouseDragged(new EventHandler<MouseEvent>() {
	            @Override
	            public void handle(MouseEvent event) {
	                primaryStage.setX(event.getScreenX() + xOffset);
	                primaryStage.setY(event.getScreenY() + yOffset);
	            }
	        });
			Scene scene = new Scene(root,1000,700);
			scene.setFill(Color.TRANSPARENT);
			scene.getStylesheets().add("application.css");
			primaryStage.getIcons().add(new Image("Jimple-Icon.png"));
            primaryStage.setTitle("Jimple Planner");
			primaryStage.setScene(scene);
			primaryStage.initStyle(StageStyle.UNDECORATED);
			primaryStage.initStyle(StageStyle.TRANSPARENT);
			primaryStage.show();
		} catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	public void begin(){
		String[] args = null;
		launch(args);
	}
	
	public void begin(String[] args) {
		launch(args);
	}
}
```
###### ./src/org/jimple/planner/ui/UiController.java
``` java
import java.io.IOException;
import java.net.URL;
import java.time.LocalDateTime;
import java.util.LinkedList;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.controlsfx.control.textfield.TextFields;
import org.jimple.planner.constants.Constants;
import org.jimple.planner.logic.Logic;
import org.jimple.planner.observers.myObserver;
import org.jimple.planner.task.Task;

import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.util.Duration;

public class UiController extends myObserver implements Initializable {
	
	protected UiPrompt prompt;
	protected UiListViewControl listViewControl;
	private LinkedList<String> cmdHistory;
	private int cmdHistoryPointer;	
	public static boolean isSearch = false;
	public static boolean isConflictedShown = false;
	protected static final Logger log= Logger.getLogger( UiController.class.getName() );
	Logic logic;
	UiFormatter listFormatter = new UiFormatter();
	private final BooleanProperty dragModeActiveProperty =
            new SimpleBooleanProperty(this, "dragModeActive", true);

	@FXML
	TextField commandBox;

	@FXML
	Text textArea, helpContent;

	@FXML
	Label messagePrompt, clock,
	todayLabel, ongoingLabel, upcomingLabel,
	agendaLabel, todoLabel,
	searchLabel, conflictedLabel;
	
	@FXML
	VBox todayEmpty, ongoingEmpty, upcomingEmpty,
	agendaEmpty, todoEmpty, archiveEmpty, searchEmpty, conflictedEmpty;

	@FXML
	Tab mainTab, agendaTab, todoTab, archiveTab;

	@FXML
	TabPane tabPanes;
	
	@FXML
	AnchorPane mainController, mainContainer,
	todayPane, nowPane, upcomingPane,
	mainContent, agendaContent, todoContent, archiveContent,
	popupLayer, searchBox, searchContent, helpBox, conflictedBox, searchList, conflictedList;

	@FXML
	StackPane stackPane;

	@FXML
	ListView<String> list;

	@FXML
	VBox overlay;
	
	@FXML
	ImageView closeButton, searchCloseButton, helpCloseButton;



	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		logic = new Logic();
		//asserts that FXML files initialises objects
		assert commandBox != null : "fx:id=\"commandBox\" was not injected: check your FXML file 'JimplUI.fxml'.";
		loadClock();
		cmdHistory = new LinkedList<String>();
		cmdHistory.add("");
		
		setEmptyListStrings();
		
		ImageView icon;
		int iconheight = 20;

		icon = new ImageView(new Image("jimpleTabIcon.png"));
		icon.setFitHeight(iconheight);
		icon.setPreserveRatio(true);
		mainTab.setGraphic(icon);
//		mainTab.setText("");
		icon = new ImageView(new Image("agendaTabIcon.png"));
		icon.setFitHeight(iconheight);
		icon.setPreserveRatio(true);
		agendaTab.setGraphic(icon);
//		agendaTab.setText("");
		icon = new ImageView(new Image("todoTabIcon.png"));
		icon.setFitHeight(iconheight);
		icon.setPreserveRatio(true);
		todoTab.setGraphic(icon);
//		todoTab.setText("");
		icon = new ImageView(new Image("archiveTabIcon.png"));
		icon.setFitHeight(iconheight);
		icon.setPreserveRatio(true);
		archiveTab.setGraphic(icon);
//		archiveTab.setText("");
		
		prompt = new UiPrompt(this);
		listViewControl = new UiListViewControl(this);
		cmdHistoryPointer = 0;
		System.out.println("initializing Jimple UI");
		logic.attach(this);
		
		TextFields.bindAutoCompletion(
                commandBox,
                Constants.STRING_ADD, Constants.STRING_EDIT,
                Constants.STRING_DELETE, Constants.STRING_SEARCH,
                Constants.STRING_UNDOTASK, Constants.STRING_HELP,
                Constants.STRING_CHANGEDIR, Constants.STRING_CHECKDIR);
		
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				commandBox.requestFocus();
			}
		});
		overlay.setVisible(false);
		assert !overlay.isVisible();
		log.log(Level.INFO,"initialising event listeners");
		commandBoxListener();
		tabPanesListener();
		update();
	 }

	private void setEmptyListStrings() {
		searchLabel.setText("Um, we found nothing. Sorry.");
//		searchLabel.setText("nothing here");
	}

	private String getCurrentTime(){
		String currentTime = "";
		currentTime +=  LocalDateTime.now().getHour() + ":" +
		String.format("%02d", LocalDateTime.now().getMinute())  + " " + 
		LocalDateTime.now().getDayOfWeek() + ", " +
		LocalDateTime.now().getDayOfMonth() + " " +
		LocalDateTime.now().getMonth() + " " +
		LocalDateTime.now().getYear();
		return currentTime;
	}
	private void loadClock() {
		final Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(1), new EventHandler<ActionEvent>() {  
		     @Override  
		     public void handle(ActionEvent event) {  
		          clock.setText(getCurrentTime());
		          if(LocalDateTime.now().getSecond() == 0){
		        	  update();
		          }
		     }  
		}));  
		timeline.setCycleCount(Animation.INDEFINITE);  
		timeline.play();
	}
	
	public void enterTriggered() throws IOException {
		String inputStr = getInputCommand();
		if (!isEmpty(inputStr)) {
			logic.execute(inputStr);
			cmdHistory.add(1, inputStr);
			clearCommandBox();
		}
	}	

	private void updateMessagePrompt(String output){
		messagePrompt.setText(output);
		fadeOut(5, messagePrompt);
	}

	/*======================================
	 * 
	 * LOADING/RELOADING TASK LIST:
	 * 
	========================================*/
	
	protected void loadDisplay() {
		tabPanesListener();
		int i = listViewControl.getCurrentTabItemIndex();
		boolean cmb = commandBox.isFocused();
		int pos = commandBox.getCaretPosition();
		loadMainTab();
		loadAgendaList();
		loadTodoList();
		loadArchiveList();
		prompt = new UiPrompt(this);
		
		if(isSearch){
			prompt.searchPrompt();
		}
		
		if(isConflictedShown){
			prompt.conflictedPrompt();
		}
		
		listViewControl.selectIndex(i);
		listViewControl.getActiveListView().scrollTo(i);
		taskSelectionListener();
		if(cmb){
			commandBox.requestFocus();
			commandBox.positionCaret(pos);
		}
	}
	
	public void loadMainTab(){
		listFormatter.formatList(logic.getAgendaList(),Constants.TYPE_TODAY);
		ListView<Task> list = listFormatter.getFormattedList();
		todayPane.getChildren().clear();
		if(list != null){
			list.setFocusTraversable(false);
			todayPane.getChildren().add(list);
		}
		else {
			todayPane.getChildren().add(todayEmpty);
		}
		
		listFormatter.formatList(logic.getEventsList(),Constants.TYPE_NOW);
		list = listFormatter.getFormattedList();
		nowPane.getChildren().clear();
		if(list != null){
			list.setFocusTraversable(false);
			nowPane.getChildren().add(list);
		}
		else {
			nowPane.getChildren().add(ongoingEmpty);
		}
		
		listFormatter.formatList(logic.getDeadlinesList(),Constants.TYPE_UPCOMING);
		list = listFormatter.getFormattedList();
		upcomingPane.getChildren().clear();
		if(list != null){
			list.setFocusTraversable(false);
			upcomingPane.getChildren().add(list);
		}
		else {
			upcomingPane.getChildren().add(upcomingEmpty);
		}
	}
	
	public void loadAgendaList() {
		listFormatter.formatList(logic.getAgendaList(),Constants.TYPE_AGENDA);
		agendaContent.getChildren().clear();
		ListView<Task> list = listFormatter.getFormattedList();
		if(list != null){
			agendaContent.getChildren().add(list);
		}
		else {
			agendaContent.getChildren().add(agendaEmpty);
		}
	}
	
	public void loadArchiveList() {
		listFormatter.formatList(logic.getArchivedList(),Constants.TYPE_ARCHIVE);
		archiveContent.getChildren().clear();
		ListView<Task> list = listFormatter.getFormattedList();
		if(list != null){
			archiveContent.getChildren().add(list);
		}
		else {
			archiveContent.getChildren().add(archiveEmpty);
		}
	}


	public void loadTodoList()  {
		listFormatter.formatList(logic.getToDoList(),Constants.TYPE_TODO);
		todoContent.getChildren().clear();
		ListView<Task> list = listFormatter.getFormattedList();
		if(list != null){
			todoContent.getChildren().add(list);
		}
		else {
			todoContent.getChildren().add(todoEmpty);
		}
	}
	
	/*======================================
	 * 
	 * FXML LAYOUT RELATED:
	 * 
	========================================*/
	private void fadeOut(float sec, Node item){
		FadeTransition ft = new FadeTransition(Duration.millis(sec*500), item);
		FadeTransition ft2 = new FadeTransition(Duration.millis(sec*1000), item);
		ft.setFromValue(1.0);
		ft.setToValue(1.0);
		ft2.setFromValue(1.0);
		ft2.setToValue(0.0);
		ft.setCycleCount(1);
		ft.play();
		
		ft.setOnFinished(new EventHandler<ActionEvent>() {

		    @Override
		    public void handle(ActionEvent event) {
		        ft2.play();
		    }
		});
	}
	
	public static void fitToAnchorPane(Node node) {
		AnchorPane.setTopAnchor(node, 0.0);
		AnchorPane.setLeftAnchor(node, 0.0);
		AnchorPane.setRightAnchor(node, 0.0);
		AnchorPane.setBottomAnchor(node, 0.0);
	}
	
	/*======================================
	 * 
	 * KEYBOARD LISTENERS:
	 * 
	========================================*/
	
	public void commandBoxListener() {
		commandBox.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent t) {
				switch(t.getCode()){
			    case ESCAPE:
					tabPanes.requestFocus();
//					listViewControl.getActiveListView().requestFocus();
					if(overlay.isVisible()){
						overlay.setVisible(false);
						isSearch = false;
						isConflictedShown = false;
						commandBox.requestFocus();
						commandBox.positionCaret(commandBox.getLength());
					}
					break;
			    case UP:
					if(cmdHistoryPointer < cmdHistory.size() - 1)
						commandBox.setText(cmdHistory.get(++cmdHistoryPointer));
					commandBox.positionCaret(commandBox.getLength());
					t.consume();
					break;
			    case DOWN:
					if(cmdHistoryPointer > 0)
						commandBox.setText(cmdHistory.get(--cmdHistoryPointer));
					commandBox.positionCaret(commandBox.getLength());
					t.consume();
					break;
				default:
					cmdHistoryPointer = 0;
					break;
				}
			}
		});
	}

	public void taskSelectionListener(){
		listViewControl.getList(listViewControl.getCurrentTab()).setOnKeyPressed(new EventHandler<KeyEvent>() {
			
			@Override
			public void handle(KeyEvent t) {
				switch(t.getCode()){
				case UP: 
					if (listViewControl.getCurrentTabItemIndex() == 0) {
						listViewControl.selectIndex(-1);
						tabPanes.requestFocus();
						listViewControl.deselectTaskItem();
						}
					break;
//				case LEFT:
//				case RIGHT:
//					break;
				case SPACE:
					if(agendaTab.isSelected())
						listViewControl.selectFirstIncompleteTask();
					break;
				case ESCAPE:
					tabPanes.requestFocus();
					listViewControl.deselectTaskItem();
					break;
				default:
					break;
				}
			}
		});
	}

	public void tabPanesListener() {
		tabPanes.setOnKeyPressed(new EventHandler<KeyEvent>() {
			
			@Override
			public void handle(KeyEvent t) {				
				if (t.getCode().isArrowKey()){
					taskSelectionListener();
				}

				switch (t.getCode()) {
				case DOWN:
					listViewControl.getActiveListView().requestFocus();
					if (listViewControl.isListViewSelectionEmpty())
						listViewControl.getActiveListView().getSelectionModel().select(0);
					break;
				case UP:
					listViewControl.getActiveListView().requestFocus();
					taskSelectionListener();
					t.consume();
					break;
				case LEFT:
				case RIGHT:
					tabPanes.requestFocus();
					break;
				case BACK_SPACE:
				case DELETE:
//					prompt.deletePrompt();
					listViewControl.deleteSelectedTask();
					break;
				default:
					taskSelectionListener();
					commandBox.requestFocus();
					commandBox.positionCaret(commandBox.getLength());
					break;
				}
			}
		});
	}
	/*======================================
	 * 
	 * COMMAND BOX RELATED:
	 * 
	========================================*/
	
	public String getInputCommand() {
		if (commandBox == null || isEmpty(commandBox.getText())) {
			return "";
		}
		return commandBox.getText();
	}

	private boolean isEmpty(String s) {
		return s == null || s.trim().isEmpty();
	}

	private void clearCommandBox() {
		commandBox.setText(null);
	}
	
	/*======================================
	 * 
	 * UI INTERACTION:
	 * 
	========================================*/
	@FXML
	private void closeButtonAction(){
	    // get a handle to the stage
	    Stage stage = (Stage) closeButton.getScene().getWindow();
	    // do what you have to do
	    stage.close();
	}

	
	@FXML
	private void searchCloseButtonAction(){
		popupLayer.getChildren().clear();
		isSearch = false;
		isConflictedShown = false;
		overlay.setVisible(false);
	}

	
	private static final class DragContext {
        public double mouseAnchorX;
        public double mouseAnchorY;
        public double initialTranslateX;
        public double initialTranslateY;
    }
	
	protected Node makeDraggable(final Node node) {
        final DragContext dragContext = new DragContext();
        final Group wrapGroup = new Group(node);
        
        wrapGroup.addEventFilter(
                MouseEvent.MOUSE_PRESSED,
                new EventHandler<MouseEvent>() {
                    public void handle(final MouseEvent mouseEvent) {
                        if (dragModeActiveProperty.get()) {
                            // remember initial mouse cursor coordinates
                            // and node position
                            dragContext.mouseAnchorX = mouseEvent.getX();
                            dragContext.mouseAnchorY = mouseEvent.getY();
                            dragContext.initialTranslateX =
                                    node.getTranslateX();
                            dragContext.initialTranslateY =
                                    node.getTranslateY();
                        }
                    }
                });

        wrapGroup.addEventFilter(
                MouseEvent.MOUSE_DRAGGED,
                new EventHandler<MouseEvent>() {
                    public void handle(final MouseEvent mouseEvent) {
                        if (dragModeActiveProperty.get()) {
                            // shift node from its initial position by delta
                            // calculated from mouse cursor movement
                            node.setTranslateX(
                                    dragContext.initialTranslateX
                                        + mouseEvent.getX()
                                        - dragContext.mouseAnchorX);
                            node.setTranslateY(
                                    dragContext.initialTranslateY
                                        + mouseEvent.getY()
                                        - dragContext.mouseAnchorY);
                        }
                    }
                });
                
        return wrapGroup;
    }
	
	@Override
	public void update() {
		loadDisplay();
	}	

	@Override
	public void update(String[] feedback) {
		int index = 0;
		if(feedback[1].matches(".*\\d+.*")) //if string contains digits
		 index = Integer.parseInt(feedback[1].replaceAll("[^\\d.]", ""));
		String tab = feedback[1].replaceAll("[0-9]","");
		switch (tab) {
		case Constants.TYPE_EVENT:
		case Constants.TYPE_DEADLINE:
			listViewControl.updateAndReload(agendaTab,index);
			break;
		case Constants.TYPE_TODO:
			listViewControl.updateAndReload(todoTab,index);
			break;
		case Constants.TYPE_ARCHIVE:
//			listViewControl.updateAndReload(archiveTab,index);
			loadDisplay();
			break;
		case Constants.TYPE_SEARCH:
			prompt.searchPrompt();
			break;
		case Constants.TYPE_CONFLICTED:
			prompt.conflictedPrompt();
			break;
		case Constants.TYPE_HELP:
			prompt.helpPrompt(feedback[0]);
			break;
		default:
			loadDisplay();
			break;
		}
		updateMessagePrompt(feedback[0]);
	}

}
```
###### ./src/org/jimple/planner/ui/UiFormatter.java
``` java
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;

import org.jimple.planner.constants.Constants;
import org.jimple.planner.task.Task;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.AnchorPane;
import javafx.util.Callback;

public class UiFormatter {

	private ArrayList<Task> formattedList;
	private ArrayList<Task> arrList;
	private ObservableList<Task> data;
	private ListView<Task> listView;
	
	public UiFormatter() {
		formattedList = new ArrayList<Task>();
	}

	public void formatList(ArrayList<Task> newList, String listType) {
		this.arrList = newList;
		formattedList.clear();

		formatType(listType);
	}

	public void formatType(String listType) {
		switch (listType) {
		case Constants.TYPE_TODAY:
			addTodayTasksToFormattedDateList();
			agendaCellFormat();
			break;
		case Constants.TYPE_NOW:
			addNowTasksToFormattedDateList();
			ongoingCellFormat();
			break;
		case Constants.TYPE_UPCOMING:
			addUpcomingTasksToFormattedDateList();
			upcomingCellFormat();
			break;
		case Constants.TYPE_AGENDA:
			addTasksToFormattedDateList();
			agendaCellFormat();
			break;
		case Constants.TYPE_ARCHIVE:
			addTasksToFormattedList();
			defaultCellFormat();
			break;
		case Constants.TYPE_DEADLINE:
			addTasksToFormattedDateList();
			agendaCellFormat();
			break;
		case Constants.TYPE_EVENT:
			addTasksToFormattedDateList();
			agendaCellFormat();
			break;
		case Constants.TYPE_TODO:
			addTasksToFormattedList();
			agendaCellFormat();
			break;
		case Constants.TYPE_SEARCH:
			addTasksToFormattedList();
			agendaCellFormat();
			break;
		default:
			formatEmptyList();
			break;
		}
	}

	private void formatEmptyList() {
		data = FXCollections.observableArrayList(formattedList);
		listView = new ListView<Task>(data);
	}

	public ListView<Task> getFormattedList() {
		if (listView == null)
			return null;
		fitToAnchorPane(listView);
		return listView;
	}

	public void fitToAnchorPane(Node node) {
		AnchorPane.setTopAnchor(node, 0.0);
		AnchorPane.setLeftAnchor(node, 0.0);
		AnchorPane.setRightAnchor(node, 0.0);
		AnchorPane.setBottomAnchor(node, 0.0);
	}

	private Task staticTask(String title, LocalDateTime fromtime) {
		Task task = new Task(title);
		task.setType(Constants.TYPE_STATIC);
		task.setIsOverDue(false);
		task.setToDate(fromtime.toString());
		return task;
	}

	private void addTodayTasksToFormattedDateList() {
		for (Task task : arrList) {
			if(task.getType().equals(Constants.TYPE_EVENT)
					&& timeDifference(task.getFromTime()) < 0
					&& timeDifference(task.getToTime()) > 0
					&& !task.getIsOverDue()){
				formattedList.add(task);
			}
			else if (LocalDateTime.now().getDayOfYear() == task.getFromTime().getDayOfYear()
					&& !task.getIsOverDue()) {
				formattedList.add(task);
			}
		}
		data = FXCollections.observableArrayList(formattedList);
		listView = new ListView<Task>(data);
		if (formattedList.isEmpty())
			listView = null;
	}

	private void addNowTasksToFormattedDateList() {
		for (Task task : arrList) {
			if(timeDifference(task.getFromTime()) < 0
					&& timeDifference(task.getToTime()) > 0){
				formattedList.add(task);
			}
			else if (LocalDateTime.now().getDayOfYear() == task.getFromTime().getDayOfYear()) {
				if (timeDifference(task.getFromTime()) < 0 && !task.getIsOverDue())
					formattedList.add(task);
			}
		}
		data = FXCollections.observableArrayList(formattedList);
		listView = new ListView<Task>(data);
		if (formattedList.isEmpty())
			listView = null;
	}

	private void addUpcomingTasksToFormattedDateList() {
		for (Task task : arrList) {
			if (timeDifference(task.getFromTime()) > 0) {
				formattedList.add(task);
				break;
			}
		}
		data = FXCollections.observableArrayList(formattedList);
		listView = new ListView<Task>(data);
		if (formattedList.isEmpty())
			listView = null;
	}

	private void addTasksToFormattedDateList() {
		String dateCounter = "";

		for (Task task : arrList) {
			if (!dateCounter.equals(task.getPrettierFromDate())) {
				dateCounter = task.getPrettierFromDate();
				formattedList.add(staticTask(dateCounter,task.getFromTime()));
			}

			formattedList.add(task);
		}
		data = FXCollections.observableArrayList(formattedList);
		listView = new ListView<Task>(data);
		if (formattedList.isEmpty())
			listView = null;
	}

	private void addTasksToFormattedList() {
		for (Task task : arrList) {
			formattedList.add(task);
		}
		data = FXCollections.observableArrayList(formattedList);
		listView = new ListView<Task>(data);
		if (formattedList.isEmpty())
			listView = null;
	}

	private void defaultCellFormat() {
		if (listView != null) {
			listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
				@Override
				public ListCell<Task> call(ListView<Task> arg0) {
					return new UiListCellDefault();
				}

			});
		}
	}

	private void agendaCellFormat() {
		if (listView != null) {
			listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
				@Override
				public ListCell<Task> call(ListView<Task> arg0) {
					return new UiListCellAgenda();
				}

			});
		}
	}

	private void upcomingCellFormat() {
		if (listView != null) {
			listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
	
				@Override
				public ListCell<Task> call(ListView<Task> arg0) {
					return new UiListCellUpcoming();
				}
	
			});
		}
	}

	private void ongoingCellFormat() {
		if (listView != null) {		
		listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
			@Override
			public ListCell<Task> call(ListView<Task> arg0) {
				return new UiListCellOngoing();
			}
		});
		}
	}
	
	protected static double timeDifference(LocalDateTime reference) {
		double minutes = Duration.between(LocalDateTime.now(), reference).toMillis() / 60000.0;
		return minutes;
	}
}
```
###### ./src/org/jimple/planner/ui/UiListCellAgenda.java
``` java
public class UiListCellAgenda extends ListCell<Task> {
	
	@FXML
	Label title, fromdate, todate, id, label, desc, conflict;
	@FXML
	CheckBox checkbox;
	@FXML
	AnchorPane anchorpane, marker;
	@FXML
	VBox vBox, date, idcolor;
	@FXML
	ImageView icon;
	@FXML
	HBox hBox;

	FXMLLoader fxmlLoader;	

	@Override
	protected void updateItem(Task item, boolean bln) {
		super.updateItem(item, bln);
		this.getStyleClass().add("listcell");
		this.setPrefWidth(0);
		
		if (item != null) {
			switch(item.getType()){
			
			//STATIC
			case Constants.TYPE_STATIC:
				this.setId(Constants.TYPE_STATIC);
				loadFXMLLayout("staticCellLayout.fxml");
				
				title.setText(item.getTitle());
				title.getStyleClass().add("staticDate");
				marker.getStyleClass().add(Constants.TYPE_STATIC + "Marker");
				break;
			
			//DEADLINE
			case Constants.TYPE_DEADLINE:
				this.setId(Constants.TYPE_DEADLINE);
				loadFXMLLayout("agendaCellLayout.fxml");
				
				setLabel(item);
				setDesc(item);
				setStyles();
				setConflict(item);
				
				if(hBox.getChildren().contains(checkbox))
					hBox.getChildren().remove(checkbox);
				if(date.getChildren().contains(todate))
					date.getChildren().remove(todate);

				icon.setImage(new Image("deadlineIconGrey.png"));
				title.setText(item.getTitle());
				id.setText(""+item.getTaskId());
				fromdate.setText(item.getPrettyFromTime());
				setDeadlineColors(item);	
				break;
			
			//EVENT
			case Constants.TYPE_EVENT:
				this.setId(Constants.TYPE_EVENT);
				loadFXMLLayout("agendaCellLayout.fxml");
				
				setLabel(item);
				setDesc(item);
				setStyles();
				setConflict(item);
				
				if(item.getIsOverDue()){
					this.setId("overdue");
				}
				else{
					this.setId("");
				}
				
				if(hBox.getChildren().contains(checkbox))
					hBox.getChildren().remove(checkbox);

				icon.setImage(new Image("eventIconGrey.png"));
				title.setText(item.getTitle());
				id.setText(""+item.getTaskId());
				fromdate.setText(item.getPrettyFromTime());
				todate.setText(item.getPrettyToTime());
				break;
			
			//TO-DO
			case Constants.TYPE_TODO:
				this.setId(Constants.TYPE_TODO);
				loadFXMLLayout("agendaCellLayout.fxml");
				
				setLabel(item);
				setDesc(item);
				setStyles();
				
				if(hBox.getChildren().contains(date))
					hBox.getChildren().remove(date);
				if(hBox.getChildren().contains(conflict))
					hBox.getChildren().remove(conflict);

				icon.setImage(new Image("todoIconGrey.png"));
				title.setText(item.getTitle());
				id.setText(""+item.getTaskId());
				break;
			}
			setGraphic(anchorpane);	
		}
	}

	private void setDeadlineColors(Task item) {
		// more than a day away
		if (UiFormatter.timeDifference(item.getFromTime()) >= 1440)
			this.setId("");
		// less than a day
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 180)
			this.setId("yellow");
		// less than an hour
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 60)
			this.setId("orange");
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 30){
			this.setId("red");
			icon.setImage(new Image("deadlineIconWhite.png"));
		}
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 0){
			this.setId("darkred");
			icon.setImage(new Image("deadlineIconWhite.png"));
		}
		else
			this.setId("overdue");
	}

	private void setConflict(Task item){
		conflict.setId("conflict");
		if(item.getConflictedTasks().isEmpty())
			conflict.setVisible(false);
		else
			conflict.setVisible(true);
	}
	private void loadFXMLLayout(String file) {
		fxmlLoader = new FXMLLoader(getClass().getResource(file));
		fxmlLoader.setController(this);
		try {
			fxmlLoader.load();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	private void setLabel(Task item) {
		label.setText(item.getTaskLabel().getLabelName());
		label.getStyleClass().add("labelText");
		label.setId("color" + item.getTaskLabel().getColourId());
		if(item.getTaskLabel().getLabelName().equals(Constants.TASK_LABEL_NAME_DEFAULT)){
			if(vBox.getChildren().contains(label))
				vBox.getChildren().remove(label);
		}
	}

	private void setDesc(Task item) {
		desc.setText(item.getDescription());
		desc.setId("description");
		if(item.getDescription().equals("")){
			if(vBox.getChildren().contains(desc))
				vBox.getChildren().remove(desc);
		}
		idcolor.setId("color" + item.getTaskLabel().getColourId());
		id.setId("color" + item.getTaskLabel().getColourId());
	}
	
	private void setStyles(){
		title.getStyleClass().add("title");
		todate.getStyleClass().add("date");
		fromdate.getStyleClass().add("date");
	}

}
```
###### ./src/org/jimple/planner/ui/UiListCellDefault.java
``` java
public class UiListCellDefault extends ListCell<Task> {
	
	@FXML
	Label title, fromdate, todate, id, label, desc;
	@FXML
	CheckBox checkbox;
	@FXML
	AnchorPane anchorpane, marker;
	@FXML
	VBox vBox, date, idcolor;
	@FXML
	ImageView icon;
	@FXML
	HBox hBox;

	FXMLLoader fxmlLoader;	

	@Override
	protected void updateItem(Task item, boolean bln) {
		super.updateItem(item, bln);
		this.getStyleClass().add("listcell");
		this.setPrefWidth(0);
		
		if (item != null) {
			switch(item.getType()){
			
			//STATIC
			case Constants.TYPE_STATIC:
				this.setId(Constants.TYPE_STATIC);
				loadFXMLLayout("staticCellLayout.fxml");
				
				title.setText(item.getTitle());
				title.getStyleClass().add("staticDate");
				marker.getStyleClass().add(Constants.TYPE_STATIC + "Marker");
				break;
			
			//DEADLINE
			case Constants.TYPE_DEADLINE:
				this.setId(Constants.TYPE_DEADLINE);
				loadFXMLLayout("defaultCellLayout.fxml");
				
				setLabel(item);
				setDesc(item);
				setStyles();
				
				if(hBox.getChildren().contains(checkbox))
					hBox.getChildren().remove(checkbox);
				if(date.getChildren().contains(todate))
					date.getChildren().remove(todate);

				icon.setImage(new Image("deadlineIconGrey.png"));
				title.setText(item.getTitle());
				id.setText(""+item.getTaskId());
				fromdate.setText(item.getPrettyFromDate() + " " + item.getPrettyFromTime());
				setDeadlineColors(item);	
				break;
			
			//EVENT
			case Constants.TYPE_EVENT:
				this.setId(Constants.TYPE_EVENT);
				loadFXMLLayout("defaultCellLayout.fxml");
				
				setLabel(item);
				setDesc(item);
				setStyles();
				
				if(item.getIsOverDue()){
					this.setId("overdue");
				}
				else{
					this.setId("");
				}
				
				if(hBox.getChildren().contains(checkbox))
					hBox.getChildren().remove(checkbox);

				icon.setImage(new Image("eventIconGrey.png"));
				title.setText(item.getTitle());
				id.setText(""+item.getTaskId());
				fromdate.setText(item.getPrettyFromDate() + " " + item.getPrettyFromTime());
				todate.setText(item.getPrettyToDate() + " " + item.getPrettyToTime());
				break;
			
			//TO-DO
			case Constants.TYPE_TODO:
				this.setId(Constants.TYPE_TODO);
				loadFXMLLayout("defaultCellLayout.fxml");
				
				setLabel(item);
				setDesc(item);
				setStyles();
				
				if(hBox.getChildren().contains(date))
					hBox.getChildren().remove(date);

				icon.setImage(new Image("todoIconGrey.png"));
				title.setText(item.getTitle());
				id.setText(""+item.getTaskId());
				break;
			}
			setGraphic(anchorpane);	
		}
	}

	private void setDeadlineColors(Task item) {
		// more than a day away
		if (UiFormatter.timeDifference(item.getFromTime()) >= 1440)
			this.setId("");
		// less than a day
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 180)
			this.setId("yellow");
		// less than an hour
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 60)
			this.setId("orange");
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 30){
			this.setId("red");
			icon.setImage(new Image("deadlineIconWhite.png"));
		}
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 0){
			this.setId("darkred");
			icon.setImage(new Image("deadlineIconWhite.png"));
		}
		else
			this.setId("overdue");
	}
	
	private void loadFXMLLayout(String file) {
		fxmlLoader = new FXMLLoader(getClass().getResource(file));
		fxmlLoader.setController(this);
		try {
			fxmlLoader.load();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	private void setLabel(Task item) {
		label.setText(item.getTaskLabel().getLabelName());
		label.getStyleClass().add("labelText");
		label.setId("color" + item.getTaskLabel().getColourId());
		if(item.getTaskLabel().getLabelName().equals(Constants.TASK_LABEL_NAME_DEFAULT)){
			if(vBox.getChildren().contains(label))
				vBox.getChildren().remove(label);
		}
	}

	private void setDesc(Task item) {
		desc.setText(item.getDescription());
		desc.setId("description");
		if(item.getDescription().equals("")){
			if(vBox.getChildren().contains(desc))
				vBox.getChildren().remove(desc);
		}
		idcolor.setId("color" + item.getTaskLabel().getColourId());
		id.setId("color" + item.getTaskLabel().getColourId());
	}
	
	private void setStyles(){
		title.getStyleClass().add("title");
		todate.getStyleClass().add("date");
		fromdate.getStyleClass().add("date");
	}

}
```
###### ./src/org/jimple/planner/ui/UiListCellOngoing.java
``` java
import java.io.IOException;

import org.jimple.planner.constants.Constants;
import org.jimple.planner.task.Task;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;

public class UiListCellOngoing extends ListCell<Task>{
	
	@FXML
	Label title, fromdate, todate, id, label, time, desc;
	@FXML
	AnchorPane anchorpane;
	@FXML
	ImageView icon;
	@FXML
	VBox vBox, idcolor;

	FXMLLoader fxmlLoader;	
	@Override
	protected void updateItem(Task item, boolean bln) {
		super.updateItem(item, bln);
		this.getStyleClass().add("listcell");
		this.setPrefWidth(0);
		if (item != null) {
			this.setId(Constants.TYPE_DEADLINE);
			loadFXMLLayout("ongoingCellLayout.fxml");
				
			setLabel(item);
			setDesc(item);
			setStyles();
			
			if(item.getIsOverDue()){
				this.setId("overdue");
			}
			else{
				this.setId("");
			}
			
			icon.setImage(new Image("eventIconGrey.png"));
			title.setText(item.getTitle());
			id.setText(""+item.getTaskId());
			fromdate.setText("from " + item.getPrettyFromDate() + " " +item.getPrettyFromTime());
			todate.setText("to " + item.getPrettyToDate() + " " +item.getPrettyToTime());
			setGraphic(anchorpane);
		}
	}
	
	private void loadFXMLLayout(String file) {
		fxmlLoader = new FXMLLoader(getClass().getResource(file));
		fxmlLoader.setController(this);
		try {
			fxmlLoader.load();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	

	private void setLabel(Task item) {
		label.setText(item.getTaskLabel().getLabelName());
		label.getStyleClass().add("labelText");
		label.setId("color" + item.getTaskLabel().getColourId());
		if(item.getTaskLabel().getLabelName().equals(Constants.TASK_LABEL_NAME_DEFAULT)){
			if(vBox.getChildren().contains(label))
				vBox.getChildren().remove(label);
		}
	}

	private void setDesc(Task item) {
		desc.setText(item.getDescription());
		desc.setId("description");
		if(item.getDescription().equals("")){
			if(vBox.getChildren().contains(desc))
				vBox.getChildren().remove(desc);
		}
		idcolor.setId("color" + item.getTaskLabel().getColourId());
		id.setId("color" + item.getTaskLabel().getColourId());
	}
	
	private void setStyles(){
		title.getStyleClass().add("title");
		fromdate.getStyleClass().add("date");
		todate.getStyleClass().add("date");
	}
}
```
###### ./src/org/jimple/planner/ui/UiListCellToday.java
``` java
import java.io.IOException;

import org.jimple.planner.constants.Constants;
import org.jimple.planner.task.Task;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;

public class UiListCellToday extends ListCell<Task> {
	
	@FXML
	Label title, date, id, label;
	@FXML
	AnchorPane anchorpane;

	FXMLLoader fxmlLoader;	

	@Override
	protected void updateItem(Task item, boolean bln) {
		super.updateItem(item, bln);
		this.getStyleClass().add("listcell");
		if (item != null) {

			// DEADLINE
			if (item.getType().equals(Constants.TYPE_DEADLINE)) {

				Text title = new Text(item.getTitle());
				Text ID = new Text();
				Text date = new Text();
				VBox vBox = new VBox();
				HBox hBox = new HBox();
				Text desc = new Text(item.getDescription());
				Region spacer = new Region();
				VBox.setVgrow(spacer, Priority.ALWAYS);
				HBox.setHgrow(spacer, Priority.ALWAYS);
//				this.getStyleClass().clear();
				this.setId(Constants.TYPE_DEADLINE);

				// more than a day away
				if (UiFormatter.timeDifference(item.getFromTime()) > 1440)
					this.setId("green");
				// less than a day
				else if (UiFormatter.timeDifference(item.getFromTime()) > 120)
					this.setId("yellow");
				// less than an hour
				else if (UiFormatter.timeDifference(item.getFromTime()) > 60)
					this.setId("orange");
				else if (UiFormatter.timeDifference(item.getFromTime()) > 30)
					this.setId("red");
				else if (UiFormatter.timeDifference(item.getFromTime()) > 0)
					this.setId("darkred");
				else
					this.setId("overdue");

				vBox = new VBox(title);
				if (!item.getDescription().equals("")) {
					vBox = new VBox(title, desc);
				}
				ID.setText(String.format("%d", item.getTaskId()));
				date.setText(String.format("%s", item.getPrettyFromTime()));
				hBox = new HBox(date, vBox, spacer, ID);
				title.setId(Constants.TYPE_DEADLINE);
				ID.setId(Constants.TYPE_DEADLINE);
				date.setId(Constants.TYPE_DEADLINE);
				hBox.setSpacing(10);
				setGraphic(hBox);
			}

			// EVENT
			else {
//				this.getStyleClass().clear();
				this.setId(Constants.TYPE_EVENT);
				fxmlLoader = new FXMLLoader(getClass().getResource("eventCellLayout.fxml"));
				fxmlLoader.setController(this);
				try {
					fxmlLoader.load();
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
				if(item.getTaskLabel().getLabelName().equals(Constants.TASK_LABEL_NAME_DEFAULT))
					label.setVisible(false);
				title.setText(item.getTitle());
				id.setText(String.format("%d", item.getTaskId()));
				label.setText(item.getTaskLabel().getLabelName());
				label.setId("color" + item.getTaskLabel().getColourId());
				date.setText(String.format("%s %s to %s %s",
						item.getPrettyFromDate(),
						item.getPrettyFromTime(),
						item.getPrettyToDate(),
						item.getPrettyToTime()));
				title.setId("event");
				id.setId("event");
				date.setId("event");
				setGraphic(anchorpane);
			}
		}
	}

}
```
###### ./src/org/jimple/planner/ui/UiListCellUpcoming.java
``` java
import java.io.IOException;

import org.jimple.planner.constants.Constants;
import org.jimple.planner.task.Task;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;

public class UiListCellUpcoming extends ListCell<Task> {

	@FXML
	Label title, date, id, label, time, desc;
	@FXML
	AnchorPane anchorpane;
	@FXML
	ImageView icon;
	@FXML
	VBox vBox, idcolor;

	FXMLLoader fxmlLoader;	

	@Override
	protected void updateItem(Task item, boolean bln) {
		super.updateItem(item, bln);
		this.getStyleClass().add("listcell");
		this.setPrefWidth(0);
		if (item != null) {
			this.setId(Constants.TYPE_DEADLINE);
			loadFXMLLayout("upcomingCellLayout.fxml");
			
			setDeadlineColors(item);	
			setLabel(item);
			setDesc(item);
			setStyles();
			
			icon.setImage(new Image("deadlineIconGrey.png"));
			title.setText(item.getTitle());
			id.setText(""+item.getTaskId());
			date.setText(item.getPrettierFromDate());
			time.setText(item.getPrettyFromTime());
				
			setGraphic(anchorpane);
		}
	}
	

	private void setDeadlineColors(Task item) {
		// more than a day away
		if (UiFormatter.timeDifference(item.getFromTime()) >= 1440)
			this.setId("");
		// less than a day
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 180)
			this.setId("yellow");
		// less than an hour
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 60)
			this.setId("orange");
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 30)
			this.setId("red");
		else if (UiFormatter.timeDifference(item.getFromTime()) >= 0)
			this.setId("darkred");
		else
			this.setId("overdue");
	}

	private void loadFXMLLayout(String file) {
		fxmlLoader = new FXMLLoader(getClass().getResource(file));
		fxmlLoader.setController(this);
		try {
			fxmlLoader.load();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	private void setLabel(Task item) {
		if(item.getTaskLabel().getLabelName().equals(Constants.TASK_LABEL_NAME_DEFAULT))
			label.setVisible(false);
		label.setText(item.getTaskLabel().getLabelName());
		label.getStyleClass().add("labelText");
		label.setId("color" + item.getTaskLabel().getColourId());
	}
	
	private void setStyles(){
		title.getStyleClass().add("title");
		date.getStyleClass().add("date");
		time.getStyleClass().add("date");
	}
	
	private void setDesc(Task item) {
		desc.setText(item.getDescription());
		desc.setId("description");
		if(item.getDescription().equals("")){
			if(vBox.getChildren().contains(desc))
				vBox.getChildren().remove(desc);
		}
		idcolor.setId("color" + item.getTaskLabel().getColourId());
		id.setId("color" + item.getTaskLabel().getColourId());
	}
}
```
###### ./src/org/jimple/planner/ui/UiListViewControl.java
``` java
import java.io.IOException;
import java.util.logging.Level;

import org.jimple.planner.constants.Constants;
import org.jimple.planner.task.Task;

import javafx.scene.control.ListView;
import javafx.scene.control.Tab;
import javafx.scene.layout.Pane;

public class UiListViewControl extends UiController{
	protected UiController controller;
	
	public UiListViewControl(UiController controller) {
		this.controller = controller;
	}
	
	protected void selectTaskAtIndex(int index){
		for(int i=0; i<getActiveListView().getItems().size(); i++)
			if(getActiveListView().getItems().get(i).getTaskId() == index){
				selectIndex(i);
				return;
			}
	}
	public void selectFirstIncompleteTask(){
		for(Task task : getActiveListView().getItems()){
			if(task.getToTime() != null && UiFormatter.timeDifference(task.getToTime())>0 && task.getType().equals(Constants.TYPE_STATIC)){
				getActiveListView().requestFocus();
				getActiveListView().getSelectionModel().select(task);
				getActiveListView().scrollTo(getActiveListView().getSelectionModel().getSelectedIndex());
				return;
			}
		}
	}
	public String getCurrentTabName() {
		return controller.tabPanes.getSelectionModel().getSelectedItem().getText();
	}

	public Tab getCurrentTab() {
		return controller.tabPanes.getSelectionModel().getSelectedItem();
	}

	public void updatePointer(int num) {
		if (num >= getActiveListView().getItems().size())
			num -= 1;
		getActiveListView().requestFocus();
		getActiveListView().getSelectionModel().select(num);
		getActiveListView().scrollTo(getActiveListView().getSelectionModel().getSelectedIndex());
	}

	public int getCurrentTabItemIndex() {
		return getActiveListView().getSelectionModel().getSelectedIndex();
	}


	protected boolean isListViewSelectionEmpty() {
		return getActiveListView().getSelectionModel().isEmpty();
	}
	
	public void deselectTaskItem() {
		getActiveListView().getSelectionModel().clearSelection();
	}

	protected void deleteSelectedTask() {
		try {
			log.log(Level.INFO, "attempting to delete selected task");
			int selectedIndex = getCurrentTabItemIndex();
			if (selectedIndex == -1)
				return;
			if(getSelectedListItem().getType().equals("static"))
				return;
			controller.logic.execute("DELETE " + getSelectedListItem().getTaskId());
			updatePointer(selectedIndex);
		} catch (IOException e) {
			log.log(Level.WARNING, "IO exception. delete not successful", e);
		}
	}

	protected Task getSelectedListItem() {
		if(getActiveListView().getSelectionModel().isEmpty())
			return null;
		return getActiveListView().getSelectionModel().getSelectedItem();
	}
	
	protected void updateAndReload(Tab tab, int index) {
		if(controller.overlay.isVisible()){
			controller.overlay.setVisible(false);
		}
		controller.loadDisplay();
		controller.tabPanes.getSelectionModel().select(tab);
		selectTaskAtIndex(index);
		controller.commandBox.requestFocus();
	}

	protected void selectIndex(int num) {
		getActiveListView().requestFocus();
		getActiveListView().getSelectionModel().select(num);
		getActiveListView().scrollTo(getActiveListView().getSelectionModel().getSelectedIndex());
	}

	@SuppressWarnings("unchecked")
	protected ListView<Task> getList(Tab tab) {
		if(((Pane) tab.getContent()).getChildren().isEmpty())
			return new ListView<Task>();
		if(((Pane) tab.getContent()).getChildren().get(0).getClass() == ListView.class)
			return (ListView<Task>) ((Pane) tab.getContent()).getChildren().get(0);
		return new ListView<Task>();
	}

	@SuppressWarnings("unchecked")
	protected ListView<Task> getActiveListView() {
		if(((Pane) controller.tabPanes.getSelectionModel().getSelectedItem().getContent()).getChildren()
				.isEmpty())
			return new ListView<Task>();

		if(((Pane) controller.tabPanes.getSelectionModel().getSelectedItem().getContent()).getChildren()
				.get(0).getClass() == ListView.class)
			return (ListView<Task>) ((Pane) controller.tabPanes.getSelectionModel().getSelectedItem().getContent()).getChildren().get(0);
		return new ListView<Task>();
	}
}
```
###### ./src/org/jimple/planner/ui/UiPrompt.java
``` java
public class UiPrompt extends UiController{
	@FXML
	AnchorPane searchBox, searchContent;	
	FXMLLoader fxmlLoader;
	
	protected UiController controller;
	
	
	public UiPrompt(UiController controller){
		this.controller = controller;
	}
	
	public void setController(UiController controller){
		this.controller = controller;
	}
	
	public void deletePrompt() {
		Pane popup = new Pane();
		VBox dialogVbox = new VBox(10);
		HBox dialogHbox = new HBox(10);
		Button deletebtn = new Button();
		Button closebtn = new Button();
		deletebtn.setText("delete");
		deletebtn.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				listViewControl.deleteSelectedTask();
				controller.popupLayer.getChildren().clear();
				controller.overlay.setVisible(false);
			}
		});
		closebtn.setText("cancel");
		closebtn.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				controller.popupLayer.getChildren().clear();
				controller.overlay.setVisible(false);
			}
		});
		dialogVbox.getChildren().add(new Text("Confirm delete?"));
		dialogHbox.getChildren().add(deletebtn);
		dialogHbox.getChildren().add(closebtn);
		dialogVbox.getChildren().add(dialogHbox);
		dialogVbox.setPadding(new Insets(10));
		popup.getChildren().add(dialogVbox);
		popup.getStyleClass().add(Constants.TYPE_POPUP);
		controller.popupLayer.getChildren().clear();
		controller.popupLayer.getChildren().add(popup);
		controller.overlay.setVisible(true);
		deletebtn.requestFocus();
	}

	protected void helpPrompt(String helpStrings) {
		controller.helpContent.setText(helpStrings);		
		controller.popupLayer.getChildren().clear();
		controller.popupLayer.getChildren().add(controller.helpBox);
		controller.overlay.setVisible(true);
	}
	
	protected void searchPrompt() {
		UiController.isSearch = true;
		controller.listFormatter.formatList(controller.logic.getSearchList(),Constants.TYPE_SEARCH);
		ListView<Task> listView = controller.listFormatter.getFormattedList();
		
		controller.searchList.getChildren().clear();
		if (listView != null) {
			listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
				@Override
				public ListCell<Task> call(ListView<Task> arg0) {
					return new UiListCellDefault();
				}

			});
		}

		if(listView != null){
			controller.searchList.getChildren().add(listView);
		}
		else {
			controller.searchList.getChildren().add(controller.searchEmpty);
		}
		controller.popupLayer.getChildren().clear();
		controller.popupLayer.getChildren().add(controller.searchBox);
		controller.overlay.setVisible(true);
	}
	
	protected void conflictedPrompt() {
		UiController.isConflictedShown = true;
		controller.listFormatter.formatList(controller.logic.getConflictedTasks(),Constants.TYPE_SEARCH);
		ListView<Task> listView = controller.listFormatter.getFormattedList();
		
		controller.conflictedList.getChildren().clear();
		if (listView != null) {
			listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
				@Override
				public ListCell<Task> call(ListView<Task> arg0) {
					return new UiListCellDefault();
				}

			});
		}

		if(listView != null){
			controller.conflictedList.getChildren().add(listView);
		}
		else {
			controller.conflictedList.getChildren().add(controller.conflictedEmpty);
		}
		controller.popupLayer.getChildren().clear();
		controller.popupLayer.getChildren().add(controller.conflictedBox);
		controller.overlay.setVisible(true);
	}	
}
```
